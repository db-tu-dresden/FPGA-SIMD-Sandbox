[{"path":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/config/global_settings.hpp", "name":"global_settings.hpp", "has_active_debug_locs":false, "absName":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/config/global_settings.hpp", "content":"#ifndef GLOBAL_SETTINGS_HPP_\u000A#define GLOBAL_SETTINGS_HPP_\u000A\u000A#include <stdio.h>\u000A#include <stdlib.h>\u000A#include <stdint.h>\u000A\u000A////////////////////////////////////////////////////////////////////////////////\u000A////////////////////////////////////////////////////////////////////////////////\u000A//// Define global parameters (on host) for data generation\u000A/**\u000A * @param distinctValues determines the generated values between 1 and distinctValues\u000A * @param multiplier\u000A * @param dataSize number of tuples respectively elements in hashVec[] and countVec[]\u000A * @param scale multiplier to determine the value of the HSIZE (note \"1.6\" corresponds to 60% more slots in the hashVec[] than there are distinctValues \u000A * @param HSIZE HashSize (corresponds to size of hashVec[] and countVec[])\u000A * @param Type define datatype which is used within all registers\u000A * @param regSize define register-size (in byte), which defines the amount of data that is load within one clock cycle :: (64=512bit; 128=1024bit; 192=1536bit; 256=2048bit;)\u000A */\u000A    //define distinctValues (uint64_t) 8000\u000A    #define distinctValues (uint64_t) 512\u000A\u000A    // change of multiplier not really necessary, but when: only in steps of 16 => e.g. 16, 32, 64 ...\u000A    // and : multiplier should be equal with value of kValuesPerLSU in kernel.cpp\u000A    #define multiplier (int) 16\u000A    #define dataSize (uint64_t) (multiplier*10240000)               // 10240000*16 = 163840000 --> MOD 16 = 0; MOD 4096 = 0\u000A    #define scale (float) (1.6)\u000A    #define HSIZE (uint64_t) (distinctValues*scale)\u000A\u000A//////// Up to this point the parameters can be adjusted.\u000A////////////////////////////////////////////////////////////////////////////////\u000A\u000A\u000A\u000A\u000A////////////////////////////////////////////////////////////////////////////////\u000A//////// DO NOT CHANGE THE FOLLOWING SETTINGS :\u000A    /**\u000A     * define datatype which is used within all registers\u000A     * NOTE: DON'T CHANGE these parameters!\u000A     */ \u000A    using Type = uint32_t;     \u000A    using TypeSigned = int32_t;\u000A\u000A    /**\u000A    * define register-size (in byte), which defines the amount of data that is load within one clock cycle\u000A    * NOTE: 64=512bit; 128=1024bit; 192=1536bit; 256=2048bit;\u000A    * NOTE: DON'T CHANGE - PLEASE USE ONLY 256 byte !\u000A    * NOTE: \tDue to current data loading approach, regSize must be 256 byte, so that\u000A    *           every register has a overall size of 2048 bit so that it can be loaded in one cycle using the 4 memory controllers\u000A    */\u000A    #define regSize (int) 256               // bytes\u000A    #define inner_regSize (int) 64          // bytes\u000A\u000A    #define elements_per_register (int) (regSize/sizeof(Type))                      // old variable name : \"elementCount\" \u000A    #define elements_per_inner_register (int) (inner_regSize/sizeof(Type))          // old variable name : \"inner_elementCount\" \u000A\u000A\u000A    // define additional variables and datastructures - only for LinearProbingFPGA_variant4()\u000A\t#define m_elements_per_vector (size_t) (elements_per_inner_register) \t\t\t// should be equivalent to (regSize)/sizeof(Type);\t\t\u000A\t#define m_HSIZE_v (size_t) ((HSIZE + m_elements_per_vector - 1) / m_elements_per_vector)\u000A    #define HSIZE_hashMap_v4 (size_t) (m_elements_per_vector * m_HSIZE_v)\u000A\t#define m_HSIZE (size_t) (HSIZE)\u000A\u000A    // only for v4_2048bit\u000A\t#define m_elements_per_vector_v4_2048bit (size_t) (elements_per_register) \t\t\t// should be equivalent to (regSize)/sizeof(Type);\t\t\u000A\t#define m_HSIZE_v_v4_2048bit (size_t) ((HSIZE + m_elements_per_vector_v4_2048bit - 1) / m_elements_per_vector_v4_2048bit)\u000A    #define HSIZE_hashMap_v4_v4_2048bit (size_t) (m_elements_per_vector_v4_2048bit * m_HSIZE_v_v4_2048bit)\t\u000A\t\t\t\u000A/////////////////////////////////////////////////////////////\u000A \t\u000A////////////////////////////////////////////////////////////////////////////////\u000A////////////////////////////////////////////////////////////////////////////////\u000A\u000A#endif      // GLOBAL_SETTINGS_HPP_"}, {"path":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/helper/helper_kernel.cpp", "name":"helper_kernel.cpp", "has_active_debug_locs":false, "absName":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/helper/helper_kernel.cpp", "content":"#include<stdio.h>\u000A#include<stdlib.h>\u000A#include<stdint.h>\u000A\u000A#include \"helper_kernel.hpp\"\u000A#include \"../config/global_settings.hpp\"\u000A\u000Ausing namespace std;\u000A\u000A// simple multiplicative hashing function\u000Aunsigned int hashx(int key, int selectable_HSIZE) {\u000A    return ((unsigned long)((unsigned int)1300000077*key)* selectable_HSIZE)>>32;\u000A}\u000A\u000A// ####################\u000A// OLD FUNCTIONS - in current version not used anymore\u000A// ####################\u000A\u000A/**\t\u000A* adaption of c++ pow-function from cmath:\u000A* pow(double base, double exponent);\u000A*\u000A* own function calculate : result = x^a\u000A* return an uint32_t value -> in this project suitable for use within 64-element registers\u000A*/\u000Auint32_t exponentiation_primitive_uint32_t(int x, int a) {\u000A\tuint32_t res = 1;\u000A\tif (a == 0) {\u000A\t\treturn res;\u000A\t} else {\u000A\t\tfor (int i=1; i<=a; i++) {\u000A\t\t\tres = res * x;\u000A\t\t}\u000A\t\treturn res;\u000A\t}\u000A}\u000A\u000A/**\t\u000A* adaption of c++ pow-function from cmath:\u000A* pow(double base, double exponent);\u000A*\u000A* own function calculate : result = x^a\u000A* return an uint64_t value -> in this project suitable for use within 64-element registers\u000A*/\u000Auint64_t exponentiation_primitive_uint64_t(int x, int a) {\u000A\tuint64_t res = 1;\u000A\tif (a == 0) {\u000A\t\treturn res;\u000A\t} else {\u000A\t\tfor (int i=1; i<=a; i++) {\u000A\t\t\tres = res * x;\u000A\t\t}\u000A\t\treturn res;\u000A\t}\u000A}\u000A\u000A/** \u000A * helper function to print an integer in bit-wise notation \u000A * Assumes little endian\u000A * print-result:    p16, p15, p14, p13, p12, p11, p10, p09, p08, p07, p06, p05, p04, p03, p02, p01\u000A * usage: printBits(sizeof(nameOfMask), &nameOfMask);\u000A */\u000Avoid printBits(size_t const size, void const * const ptr) {\u000A    unsigned char *b = (unsigned char*) ptr;\u000A    unsigned char byte;\u000A    int i, j;\u000A    \u000A    for (i = size-1; i >= 0; i--) {\u000A        for (j = 7; j >= 0; j--) {\u000A            byte = (b[i] >> j) & 1;\u000A            printf(\"%u \", byte);\u000A        }\u000A    }\u000A    puts(\"\");\u000A}"}, {"path":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/helper/helper_kernel.hpp", "name":"helper_kernel.hpp", "has_active_debug_locs":false, "absName":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/helper/helper_kernel.hpp", "content":"#ifndef HELPER_KERNEL_HPP\u000A#define HELPER_KERNEL_HPP\u000A\u000A#include <CL/sycl.hpp>\u000A\u000Ausing namespace std;\u000A\u000Aextern SYCL_EXTERNAL unsigned int hashx(int key, int selectable_HSIZE);\u000A\u000Auint32_t exponentiation_primitive_uint32_t(int x, int a);\u000Auint64_t exponentiation_primitive_uint64_t(int x, int a);\u000Avoid printBits(size_t const size, void const * const ptr);\u000A\u000A#endif  // HELPER_KERNEL_HPP"}, {"path":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/helper/helper_main.cpp", "name":"helper_main.cpp", "has_active_debug_locs":false, "absName":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/helper/helper_main.cpp", "content":"#include <stdio.h>\u000A#include <stdlib.h>\u000A#include <sys/types.h>\u000A#include <time.h>\u000A#include <iostream>\u000A#include <chrono>\u000A#include <algorithm>\u000A#include <array>\u000A#include <iomanip>\u000A#include <chrono>\u000A#include <numeric>\u000A#include <vector>\u000A#include <time.h>\u000A#include <tuple>\u000A#include <utility>\u000A\u000A#include \"helper_main.hpp\"\u000A#include \"../config/global_settings.hpp\"\u000A\u000Ausing namespace std;\u000A\u000Avoid initializeHashMap(uint32_t* hashVec, uint32_t* countVec) {\u000A    //initalize hash array with zeros\u000A    for (int i=0; i<HSIZE;i++) {\u000A        hashVec[i]=0;\u000A        countVec[i]=0;\u000A    }\u000A}\u000A\u000A//validates only total count\u000Avoid validate(uint32_t* hashVec, uint32_t* countVec) {\u000A    uint64_t sum=0;\u000A    for (int i=0; i<HSIZE; i++) {\u000A        if (hashVec[i]>0) {\u000A            sum+=countVec[i];\u000A        }\u000A    }\u000A    std::cout << \"Final result check: compare parameter dataSize against sum of all count values in countVec:\" << std::endl;\u000A    std::cout << dataSize <<\" \" << sum << std::endl;\u000A    std::cout <<\" \" << std::endl;\u000A}\u000A\u000A//validates if every entry has the right number of elements and if elements are missing.\u000Avoid validate_element(uint32_t *data, uint32_t*hashVec, uint32_t* countVec) {\u000A    std::cout << \"Element Validation\\n\";\u000A    size_t errors_found = 0;\u000A    // uint32_t lowest = 0;         // variable not used\u000A    size_t m_id = 0;\u000A    uint32_t *nr_list = new uint32_t[HSIZE];\u000A    uint32_t *nr_count = new uint32_t[HSIZE];\u000A\u000A    for(size_t nr = 0; nr < dataSize; nr++){\u000A        uint32_t value = data[nr];\u000A        bool found = false;\u000A        for(size_t i = 0; i < m_id; i++){\u000A            if(nr_list[i] == value){\u000A                found = true;\u000A                nr_count[i]++;\u000A            }\u000A        }\u000A        if(!found){\u000A            nr_list[m_id] = value;\u000A            nr_count[m_id] = 1;\u000A            m_id++;\u000A        }\u000A    }\u000A\u000A    for(size_t val_id = 0; val_id < m_id; val_id++){\u000A        uint32_t validation_val = nr_list[val_id];\u000A        bool found = false;\u000A        for(size_t hash_id = 0; hash_id < HSIZE; hash_id++){\u000A            uint32_t hash_val = hashVec[hash_id];\u000A            if(hash_val == validation_val){\u000A                found = true;\u000A                if(countVec[hash_id] != nr_count[val_id]){\u000A                    std::cout << \"\\tERROR\\tCount\\t\\t\" << hash_val << \"\\thas a count of \" \u000A                        << countVec[hash_id] << \"\\tbut should have a count of \" \u000A                        << nr_count[val_id] << std::endl;\u000A                    errors_found++;\u000A                }\u000A                break;\u000A            }\u000A        }\u000A        if(!found){\u000A            std::cout << \"\\tERROR\\tMissing\\t\\t\" << validation_val << \"\\tis missing. It has a count of \" \u000A                << nr_count[val_id] << std::endl; \u000A            errors_found++;\u000A        }\u000A    }\u000A    if(errors_found == 1){\u000A        std::cout << \"Element Validation found \" << errors_found << \" Error\\n\";\u000A    }\u000A    else if(errors_found > 1){\u000A        std::cout << \"Element Validation found \" << errors_found << \" Errors\\n\";\u000A    }else{\u000A        std::cout << \"Element Validation didn't find any Errors\\n\";\u000A    }\u000A}"}, {"path":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/helper/helper_main.hpp", "name":"helper_main.hpp", "has_active_debug_locs":false, "absName":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/helper/helper_main.hpp", "content":"#ifndef HELPER_MAIN_HPP\u000A#define HELPER_MAIN_HPP\u000A\u000A#include \"../config/global_settings.hpp\"\u000A\u000Ausing namespace std;\u000A\u000Avoid initializeHashMap(uint32_t* hashVec, uint32_t* countVec);\u000Avoid validate(uint32_t* hashVec, uint32_t* countVec);\u000Avoid validate_element(uint32_t *data, uint32_t*hashVec, uint32_t* countVec);\u000A\u000A/**\u000A  *  Generate a data array with random values between 1 and #distinctValues\u000A  *  The array is dynamically sized. The number of elements corresponds to the value in dataSize.\u000A  * @todo : change data generation function to a function with real random values\u000A  */\u000Atemplate <typename T>\u000Avoid generateData(T* arr) {\u000A    int i;    \u000A    for(i=0;i<dataSize;i+=1){\u000A        arr[i] = 1+ (rand() % distinctValues);\u000A    }\u000A} \u000A\u000A#endif  // HELPER_MAIN_HPP"}, {"path":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load512bit_v5/kernel.cpp", "name":"kernel.cpp", "has_active_debug_locs":false, "absName":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load512bit_v5/kernel.cpp", "content":"#include <stdio.h>\u000A#include <stdlib.h>\u000A#include <sys/types.h>\u000A#include <sys/time.h>\u000A#include <time.h>\u000A#include <immintrin.h>\u000A#include <emmintrin.h>\u000A#include <smmintrin.h>\u000A#include <stdbool.h>\u000A#include <stdint.h>\u000A#include <string.h>\u000A#include <stdio.h>\u000A#include <stdlib.h>\u000A#include <iostream>\u000A#include <stdexcept>\u000A\u000A#include <sycl/ext/intel/fpga_extensions.hpp>\u000A\u000A#include \"kernel.hpp\"\u000A#include \"../config/global_settings.hpp\"\u000A#include \"../helper/helper_kernel.hpp\"\u000A#include \"../primitives/primitives.hpp\"\u000A\u000A#include \"lib/lib.hpp\"\u000A////////////////////////////////////////////////////////////////////////////////\u000A////////////////////////////////////////////////////////////////////////////////\u000A//\tOVERVIEW about functions in kernel.cpp\u000A//\u000A//\tLinearProbingFPGA_variant1() == SoA_v1 -- SIMD for FPGA function v1 -  without aligned_start; version descbribed in paper\u000A// \tLinearProbingFPGA_variant2() == SoA_v2 -- SIMD for FPGA function v2 - first optimization: using aligned_start\u000A//\tLinearProbingFPGA_variant3() == SoA_v3 -- SIMD for FPGA function v3 - with aligned start and approach of using permutexvar_epi32\u000A//\tLinearProbingFPGA_variant4() == SoAoV_v1 -- SIMD for FPGA function v4 - use a vector with elements of type <fpvec<Type, regSize> as hash_map structure \"around\" the registers\u000A// \tLinearProbingFPGA_variant5() == SoA_conflict_v1 -- SIMD for FPGA function v5 - \tsearch in loaded data register for conflicts and add the sum of occurences per element to countVec instead of \u000A//\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tprocess each item individually, even though it occurs multiple times in the currently loaded data\t\t\u000A// \u000A////////////////////////////////////////////////////////////////////////////////\u000A////////////////////////////////////////////////////////////////////////////////\u000A\u000A////////////////////////////////////////////////////////////////////////////////\u000A//// Board globals. Can be changed from command line.\u000A// default to values in pac_s10_usm BSP\u000A#ifndef DDR_CHANNELS\u000A#define DDR_CHANNELS 4\u000A#endif\u000A\u000A#ifndef DDR_WIDTH\u000A#define DDR_WIDTH 64 // bytes (512 bits)\u000A#endif\u000A\u000A#ifndef PCIE_WIDTH\u000A#define PCIE_WIDTH 64 // bytes (512 bits)\u000A#endif\u000A\u000A#ifndef DDR_INTERLEAVED_CHUNK_SIZE\u000A#define DDR_INTERLEAVED_CHUNK_SIZE 4096 // bytes\u000A#endif\u000A\u000Aconstexpr size_t kDDRChannels = DDR_CHANNELS;\t\t\u000Aconstexpr size_t kDDRWidth = DDR_WIDTH;\t\t\t\t\u000Aconstexpr size_t kDDRInterleavedChunkSize = DDR_INTERLEAVED_CHUNK_SIZE;\u000A// constexpr size_t kPCIeWidth = PCIE_WIDTH;\u000A////////////////////////////////////////////////////////////////////////////////\u000A\u000A////////////////////////////////////////////////////////////////////////////////\u000A//// declaration of the classes\u000Aclass kernelV5;\u000A\u000A////////////////////////////////////////////////////////////////////////////////\u000A////////////////////////////////////////////////////////////////////////////////\u000A\u000A/**\u000A * Variant 5 of a hasbased group_count implementation for FPGA.\u000A * The algorithm uses the LinearProbing approach to perform the group-count aggregation.\u000A * @param q device queue\u000A * @param arr_d the input data array\u000A * @param hashVec_d store value of k at position hashx(k)\u000A * @param countVec_d store the count of occurence of k at position hashx(k)\u000A * @param match_32bit_d\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// defined in concerned function, not part of paramater list anymore \u000A * @param dataSize number of tuples respectively elements in hashVec[] and countVec[]\t\t// global defined, not part of paramater list anymore \u000A * @param HSIZE HashSize (corresponds to size of hashVec[] and countVec[])\t\t\t\t\t// global defined, not part of paramater list anymore \u000A * @param size = number_CL*16 with number_CL = number_CL_buckets * (4096/16);\u000A */\u000Avoid LinearProbingFPGA_variant5(queue& q, uint32_t *arr_d, uint32_t *hashVec_d, uint32_t *countVec_d, size_t size) {\u000A////////////////////////////////////////////////////////////////////////////////\u000A//// Check global board settings (regarding DDR4 config), global parameters & calculate iterations parameter\u000A\tstatic_assert(kDDRWidth % sizeof(int) == 0);\u000A  \tstatic_assert(kDDRInterleavedChunkSize % sizeof(int) == 0);\t\t\t\t\t\t\t\u000A\u000A\tconstexpr size_t kValuesPerInterleavedChunk = kDDRInterleavedChunkSize / sizeof(Type);\u000A\tconstexpr size_t kValuesPerLSU = kDDRWidth / sizeof(Type);\t\t\u000A\tstatic_assert(kValuesPerInterleavedChunk % kValuesPerLSU == 0);\u000A\u000A\tconstexpr size_t kNumLSUs = kDDRChannels;  \u000A\t// constexpr size_t kIterationsPerChunk = kValuesPerInterleavedChunk / kValuesPerLSU;    \u000A\u000A\t// ensure size is nice\u000A\tassert(size % kValuesPerInterleavedChunk == 0);\u000A\tassert(size % kNumLSUs == 0);\u000A\u000A\t// ensure dataSize is nice\u000A\tassert(dataSize % elements_per_register == 0);\u000A\tassert(dataSize % kValuesPerLSU == 0);\u000A\tassert(dataSize % kNumLSUs == 0);   \u000A\u000A\t// size_t total_chunks = size / kValuesPerInterleavedChunk;\u000A\t// size_t chunks_per_lsu = total_chunks / kNumLSUs;\u000A\t// calculation of iterations; value could be bigger than dataSize/elements_per_register\u000A\t// const size_t iterations = chunks_per_lsu * kIterationsPerChunk;  \u000A\u000A\t// recalculate iterations parameter, because we load only single 512bit register per iteration in this approach\t\u000A\tconst size_t iterations = size / elements_per_inner_register;\u000A\u000A\t// ensure global defined regSize and inner_regSize is nice\u000A\tassert(regSize == 256);\u000A\tassert(inner_regSize == 64);\u000A\u000A\t#define EMPTY_SPOT 0\u000A////////////////////////////////////////////////////////////////////////////////\u000A\u000A////////////////////////////////////////////////////////////////////////////////\u000A//// starting point of the logic of the algorithm\u000A\u000A\tq.submit([&](handler& h) {\u000A\t\th.single_task<kernelV5>([=]() [[intel::kernel_args_restrict]] {\u000A\u000A\t\t\tdevice_ptr<Type> input(arr_d);\u000A\t\t\tdevice_ptr<Type> hashVec_globalMem(hashVec_d);\u000A\t\t\tdevice_ptr<Type> countVec_globalMem(countVec_d);\u000A\t\t\t\u000A\t\t\t////////////////////////////////////////////////////////////////////////////////\u000A\t\t\t//// declare private variables for hashVec & countVec\u000A\t\t\t/* The Intel oneAPI DPC++/C++ Compiler creates a kernel memory in hardware.\u000A\t\t\t* Kernel memory is sometimes referred to as on-chip memory because it is created from\u000A\t\t\t* memory sources (such as RAM blocks) available on the FPGA.\u000A\t\t\t* \u000A\t\t\t* Here we want to create the hashVec and CountVec Arrays inside the kernel with local Memory,\u000A\t\t\t* more accurate with M20K RAM Blocks. This memory type is significantly faster than store/load operations from/to global memory.\u000A\t\t\t* With this change, we only need to write every element of both arrays once to the global memory at the end of the algorithm.\u000A\t\t\t*  \u000A\t\t\t* In the ideal case, the compiler creates both data structures as stall-free. But that depends on whether the algorithm allows it or not.\u000A\t\t\t* Due to the fact that our HSIZE can also be significantly larger, we consciously use M20K RAM blocks instead of MLAB memory, \u000A\t\t\t* since the STRATIX FPGA has approx. 10000 M20K blocks - which corresponds to approx. 20MB and is therefore better suited for larger data structures.\u000A\t\t\t*/\u000A\t\t\t// USING M20K RAM BLOCKS on FPGA to implement hashVec and countVec (embedded memory) and initialize these with zero\u000A\t\t\t[[intel::fpga_memory(\"BLOCK_RAM\")]] std::array<Type, HSIZE> hashVec;\u000A\t\t\t[[intel::fpga_memory(\"BLOCK_RAM\")]] std::array<Type, HSIZE> countVec;\u000A\u000A\t\t\t#pragma unroll 16\t\t\u000A\t\t\tfor(int i=0; i<HSIZE; i++) {\u000A\t\t\t\thashVec[i]=0; \u000A\t\t\t\tcountVec[i]=0;\t\u000A\t\t\t}\u000A\u000A\t\t\t// create buffer array with embedded memory on FPGA as register\u000A\t\t\t// create a buffer on FPGA to realize buffer[] which is needed to store conflicts and hash_values within the following algorithm\u000A\t\t\t[[intel::fpga_register]] std::array<Type, elements_per_inner_register> buffer;\t\u000A\t\t\t#pragma unroll 16\u000A\t\t\tfor(int i=0; i<elements_per_inner_register; i++) {\t\u000A\t\t\t\tbuffer[i] = 0;\u000A\t\t\t}\u000A\u000A\t\t\t// create counting parameter p on local memory of FPGA\u000A\t\t\t// [[intel::fpga_register]] size_t p[1];\u000A\t\t\t// p[0]=0;\u000A\t\t\t////////////////////////////////////////////////////////////////////////////////\u000A\t\t\t////////////////////////////////////////////////////////////////////////////////\u000A\u000A\t\t\t////////////////////////////////////////////////////////////////////////////////\u000A\t\t\t//// declare some basic masks and arrays\u000A\t\t\tType one = 1;\u000A\t\t\tType zero = 0;\u000A\t\t\t// Because we use the oneMask and zeroMask only inside the inner-part of the algorithm, we create them with <Type, inner_regSize>\u000A\t\t\t// -> with 16 elements of type uint32_t (32bit) => 512bit per register\u000A\t\t\tfpvec<Type, inner_regSize> oneMask = set1<Type, inner_regSize>(one);\u000A\t\t\tfpvec<Type, inner_regSize> zeroMask = set1<Type, inner_regSize>(zero);\u000A\t\t\t\u000A\t\t\t// convert variable HSIZE to 32-bit\u000A\t\t\t// we don't need HSIZE as 64-bit integer, but this datatype cost much ressources on FPGA\u000A\t\t\tType tmp_HSIZE = (Type)HSIZE;\u000A\t\t\tfpvec<Type, inner_regSize> tmp_HSIZE_mask = set1<Type, inner_regSize>(tmp_HSIZE);\u000A\t\t\t////////////////////////////////////////////////////////////////////////////////\u000A\t\t\t////////////////////////////////////////////////////////////////////////////////\u000A\t\t\t\u000A\t\t\t// AVX512-implementation of this LinearProbing-algorithm_v5 (SoA_conflict_v1) was actually using this while-loop.\u000A\t\t\t// We replaced this solution through our for-loop for the loading cycles similar to the previous versions.\u000A\t\t\t// while(p + elements_per_register < dataSize){\u000A\u000A\t\t\t// #########################################\u000A\t\t\t// #### START OF FPGA parallelized part ####\u000A\t\t\t// #########################################\u000A\t\t\t// define dataVec register\u000A\t\t\tfpvec<Type, inner_regSize> dataVec;\u000A\u000A\t\t\t// iterate over input data with a SIMD register size of 512bit (inner_regSize bytes => elements_per_inner_register(=16) elements)\u000A\t\t\tfor(int i_cnt=0; i_cnt<iterations; i_cnt++) {\u000A\u000A\t\t\t\t// Load complete CL (register) in one clock cycle (same for PCIe and DDR4)\u000A\t\t\t\tdataVec = load<Type, inner_regSize>(input, i_cnt);\u000A\u000A\t\t\t\t// iterate over input data / in this algorithm with a full register per cycle\u000A\u000A\t\t\t\t// how much the given count should be increased for the given input.\u000A\t\t\t\tfpvec<Type, inner_regSize> input_add = set1<Type, inner_regSize>(one);\u000A\u000A\t\t\t\t// search for conflicts\u000A\t\t\t\tfpvec<Type, inner_regSize> conflicts = conflict_epi32(dataVec);\u000A\t\t\t\t// masked to indicate were there is a conflict in the input_values and were not.\u000A\t\t\t\tfpvec<Type, inner_regSize> no_conflicts_mask = cmpeq_epi32_mask(zeroMask, conflicts);\u000A\t\t\t\tfpvec<Type, inner_regSize> negativ_no_conflicts_mask = knot(no_conflicts_mask);\u000A\u000A\t\t\t\t// we need to store the conflicts so we can interprete them as masks. and access them.\u000A\t\t\t\t// we are only interested in the enties that are not zero. That means the conflict cases.\t\t\t\t\t\u000A\t\t\t\tmask_compressstoreu_epi32(buffer, negativ_no_conflicts_mask, conflicts);\u000A\u000A\t\t\t\tsize_t conflict_count = popcount_builtin(negativ_no_conflicts_mask);\u000A\t\t\t\t// add at all the places where the conflict masks indicates that there is an overlap\u000A\t\t\t\tfor(size_t i = 0; i < conflict_count; i++){\u000A\t\t\t\t\tfpvec<Type, inner_regSize> tmp_buffer_mask = setX_singleValue<Type, inner_regSize>(buffer[i]);\u000A\t\t\t\t\tinput_add = mask_add_epi32<Type, inner_regSize>(input_add, tmp_buffer_mask, input_add, oneMask);\u000A\t\t\t\t}\u000A\u000A\t\t\t\t// we override the value and what to add with zero in the positions where we have a conflict.\u000A\t\t\t\t// NOTE: This steps might not be necessary.\u000A\t\t\t\tdataVec = mask_set1(dataVec, negativ_no_conflicts_mask, zero);\u000A\t\t\t\tinput_add = mask_set1(input_add, negativ_no_conflicts_mask, zero);\u000A\u000A\t\t\t\t// now we can calculate the hashes.\u000A\t\t\t\t// for this we can store the dataVec hash it and load it\u000A\t\t\t\t// OR we use the input and hash it save it in to buffer and than make a maskz load for the hashed data\u000A\t\t\t\t// OR we have a simdifyed Hash Algorithm! For the most cases we would need an avx... mod. \u000A\t\t\t\t// _mm512_store_epi32(buffer, dataVec);\u000A\t\t\t\t#pragma unroll\u000A\t\t\t\tfor(size_t i = 0; i < elements_per_inner_register; i++){\u000A\t\t\t\t\t// old : buffer[i] = hashx(input[p + i], HSIZE);\u000A\t\t\t\t\t// we don't need this offset-calculation (p+i), because we iterate through our data-register (dataVec), which\u000A\t\t\t\t\t// will be loaded with new data in every data-loading-iteration. So we just have to iterate through the elements within this register. \u000A\t\t\t\t\tbuffer[i] = hashx(dataVec.elements[i], HSIZE);\u000A\t\t\t\t}\u000A\t\t\t\t\t\u000A\t\t\t\tfpvec<Type, inner_regSize> hash_map_position = mask_loadu_from_buffer<Type, inner_regSize>(no_conflicts_mask, buffer, (Type)0); \t// these are the hash values\u000A\u000A\t\t\t\twhile(mask2int(no_conflicts_mask) !=0) {\t\t\u000A\t\t\t\t\t// now we can gather the data from the different positions where we have no conflicts.\u000A\t\t\t\t\tfpvec<Type, inner_regSize> hash_map_value = mask_i32gather_epi32(zeroMask, no_conflicts_mask, hash_map_position, hashVec);\u000A\t\t\t\t\t// with these we can calculate the different possible hits. Real hits and empty positions.\u000A\t\t\t\t\tfpvec<Type, inner_regSize> foundPos = mask_cmpeq_epi32_mask(no_conflicts_mask, dataVec, hash_map_value);\u000A\t\t\t\t\tfpvec<Type, inner_regSize> foundEmpty = mask_cmpeq_epi32_mask(no_conflicts_mask, zeroMask, hash_map_value);\u000A\u000A\t\t\t\t\tif(mask2int(foundPos) != 0){\t\t//A\u000A\t\t\t\t\t\t// Now we have to gather the count. IMPORTANT! the count is a 32bit integer. \u000A\t\t\t\t\t\t// FOR NOW THIS IS CORRECT BUT MIGHT CHANGE LATER!\u000A\t\t\t\t\t\t// For 64bit integers we would need to find a different solution!\u000A\t\t\t\t\t\tfpvec<Type, inner_regSize> hash_map_value = mask_i32gather_epi32(zeroMask, foundPos, hash_map_position, countVec);\u000A\t\t\t\t\t\t// on this count we can know add the pre calculated values. and scatter it back to their positions\u000A\t\t\t\t\t\thash_map_value = maskz_add_epi32(foundPos, hash_map_value, input_add);\u000A\t\t\t\t\t\tmask_i32scatter_epi32<Type, inner_regSize>(countVec, foundPos, hash_map_position, hash_map_value);\u000A\t\t\t\t\t\t\t\t\u000A\t\t\t\t\t\t// finaly we remove the entries we just saved from the no_conflicts_mask such that the work to be done shrinkes.\u000A\t\t\t\t\t\tno_conflicts_mask = kAndn(foundPos, no_conflicts_mask);\u000A\t\t\t\t\t}\u000A\u000A\t\t\t\t\tif(mask2int(foundEmpty) != 0){\t\t//B1\u000A\t\t\t\t\t\t// now we have to check for conflicts to prevent two different entries to write to the same position.\u000A\t\t\t\t\t\tfpvec<Type, inner_regSize> saveConflicts = maskz_conflict_epi32<Type, inner_regSize>(foundEmpty, hash_map_position);\u000A\t\t\t\t\t\tfpvec<Type, inner_regSize> empty = set1<Type, inner_regSize>(mask2int_uint32_t(foundEmpty));\u000A\t\t\t\t\t\tsaveConflicts = register_and<Type, inner_regSize>(saveConflicts, empty);\u000A\t\t\t\t\t\t\t\u000A\t\t\t\t\t\tfpvec<Type, inner_regSize> to_save_data = cmpeq_epi32_mask<Type, inner_regSize>(zeroMask, saveConflicts);\u000A\u000A\t\t\t\t\t\tto_save_data = kAnd(to_save_data, foundEmpty);\u000A\u000A\t\t\t\t\t\t// with the cleaned mask we can now save the data.\u000A\t\t\t\t\t\tmask_i32scatter_epi32<Type, inner_regSize>(hashVec, to_save_data, hash_map_position, dataVec);\u000A\t\t\t\t\t\tmask_i32scatter_epi32<Type, inner_regSize>(countVec, to_save_data, hash_map_position, input_add);\u000A\u000A\t\t\t\t\t\t//and again we need to remove the data from the todo list\u000A\t\t\t\t\t\tno_conflicts_mask = kAndn(to_save_data, no_conflicts_mask);\u000A\t\t\t\t\t}\u000A\u000A\t\t\t\t\t// afterwards we add one on the current positions of the still to be handled values.\u000A\t\t\t\t\thash_map_position = maskz_add_epi32(no_conflicts_mask, hash_map_position, oneMask);\u000A\u000A\t\t\t\t\t// Since there isn't a modulo operation we have to check if the values are bigger or equal the HSIZE AND IF we have to set them to zero\u000A\t\t\t\t\t// fpvec<Type, inner_regSize> tmp_HSIZE_mask = set1<Type, inner_regSize>(tmp_HSIZE);\t\t\t// << we declare this mask before the loop\u000A\t\t\t\t\tfpvec<Type, inner_regSize> tobig = mask_cmp_epi32_mask_NLT(no_conflicts_mask, hash_map_position, tmp_HSIZE_mask);\u000A\t\t\t\t\thash_map_position = mask_set1(hash_map_position, tobig, (Type)0);\u000A\u000A\t\t\t\t\t// we repeat this for one vector as long as their is still a value to be saved.\u000A\t\t\t\t}\u000A\t\t\t\t//p[0] += elements_per_inner_register;\u000A\t\t\t}\u000A\t\t\t// #######################################\u000A\t\t\t// #### END OF FPGA parallelized part ####\u000A\t\t\t// #######################################\u000A\u000A\t\t\t/*\t\t\u000A\t\t\t//scalar remainder\t\u000A\t\t\t// As long as we use a dataSize mod 4096 = 0, the algorithm doesn't leave any rest; scalar remainder will not be entered --> we deactivate them for performance reasons\u000A \t\t\twhile(p[0] < dataSize){\u000A\t\t\t\t// get the possible possition of the element.\u000A\t\t\t\tType currentValue = input[p[0]];\u000A\t\t\t\tType hash_key = hashx(currentValue, HSIZE);\u000A\u000A\t\t\t\twhile(1){\u000A\t\t\t\t\t// get the value of this position\u000A\t\t\t\t\tType value = hashVec[hash_key];\u000A\t\t\t\t\t\u000A\t\t\t\t\t// Check if it is the correct spot\u000A\t\t\t\t\tif(value == currentValue){\u000A\t\t\t\t\t\tcountVec[hash_key]++;\u000A\t\t\t\t\t\tbreak;\u000A\t\t\t\t\t\t\u000A\t\t\t\t\t// Check if the spot is empty\u000A\t\t\t\t\t}else if(value == EMPTY_SPOT){\u000A\t\t\t\t\t\thashVec[hash_key] = currentValue;\u000A\t\t\t\t\t\tcountVec[hash_key] = 1;\u000A\t\t\t\t\t\tbreak;\u000A\t\t\t\t\t\t\u000A\t\t\t\t\t}\u000A\t\t\t\t\telse{\u000A\t\t\t\t\t\t//go to the next spot\u000A\t\t\t\t\t\thash_key = (hash_key + 1);\u000A\t\t\t\t\t\tif (hash_key >= HSIZE) {\u000A\t\t\t\t\t\t\thash_key = hash_key-HSIZE;\u000A\t\t\t\t\t\t}\t\u000A\t\t\t\t\t\t//we assume that the hash_table is big enough\u000A\t\t\t\t\t}\u000A\t\t\t\t}\u000A\t\t\t\tp[0]++;\u000A\t\t\t} */\u000A\t\t\t\t\t\u000A\t\t\t// store results back to global memory\u000A\t\t\t// memcpy(hashVec_globalMem, hashVec, HSIZE * sizeof(Type));\u000A\t\t\t// memcpy(countVec_globalMem, countVec, HSIZE * sizeof(Type));\t\t--> will be handled as for-loop with #pragma unroll through the compiler -> not working for large HSIZE\u000A\t\t\t// we can't use #pragma unroll, due to unknown value of HSIZE \u000A\t\t\t// -> High value of HSIZE in combination with pragma unroll can cause HIGH RAM UITLIZATION (~199%)\u000A\t\t\t// Because we know, that we are working often with 16 elements per register (16x32bit=512bit), we unroll with factor 16\u000A\t\t\t#pragma unroll 16\t\t\t\t\t\u000A\t\t\tfor(int i=0; i<HSIZE; i++) {\u000A\t\t\t\thashVec_globalMem[i]=hashVec[i]; \u000A\t\t\t\tcountVec_globalMem[i]=countVec[i]; \t\u000A\t\t\t}\u000A\u000A\t\t\t// multiple improvements are possible:\u000A\t\t\t// 1.   we could increase the performance of the worst case first write.\u000A\t\t\t// 2.   we could absorbe the scalar remainder with overflow masks\u000A\t\t\t// these would probably have a negative impact on  the overall performance.\u000A\t\t});\u000A\t}).wait();\u000A}   \u000A//// end of LinearProbingFPGA_variant5()\u000A////////////////////////////////////////////////////////////////////////////////"}, {"path":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load512bit_v5/kernel.hpp", "name":"kernel.hpp", "has_active_debug_locs":false, "absName":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load512bit_v5/kernel.hpp", "content":"#ifndef KERNEL_HPP\u000A#define KERNEL_HPP\u000A\u000A#include <CL/sycl.hpp>\u000A#include <sycl/ext/intel/fpga_extensions.hpp>\u000A\u000A#include \"lib/lib.hpp\"\u000A#include \"../config/global_settings.hpp\"\u000A#include \"../primitives/primitives.hpp\"\u000A\u000Ausing namespace sycl;\u000A\u000A\u000Aclass kernelV5;\u000A\u000Avoid LinearProbingFPGA_variant5(queue& q, uint32_t *arr_d, uint32_t *hashVec_d, uint32_t *countVec_d, size_t size);\u000A\u000A#endif  // KERNEL_HPP"}, {"path":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load512bit_v5/lib/lib.hpp", "name":"lib.hpp", "has_active_debug_locs":false, "absName":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load512bit_v5/lib/lib.hpp", "content":"//==============================================================\u000A// Copyright Intel Corporation\u000A//\u000A// SPDX-License-Identifier: MIT\u000A// =============================================================\u000A\u000A// SYCL functions\u000ASYCL_EXTERNAL float SyclSquare(float);\u000ASYCL_EXTERNAL float SyclSqrt(float);\u000ASYCL_EXTERNAL int SyclMult(int x, int y);\u000A\u000ASYCL_EXTERNAL std::array<int, 16> SyclBubbleSort( std::array<int, 16> a );\u000A\u000A\u000A// RTL functions\u000ASYCL_EXTERNAL extern \"C\" unsigned RtlByteswap(unsigned x);\u000ASYCL_EXTERNAL extern \"C\" unsigned AdderUint(unsigned int a, unsigned int b );\u000A"}, {"path":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load512bit_v5/lib/lib_rtl_model.cpp", "name":"lib_rtl_model.cpp", "has_active_debug_locs":false, "absName":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load512bit_v5/lib/lib_rtl_model.cpp", "content":"//==============================================================\u000A// Copyright Intel Corporation\u000A//\u000A// SPDX-License-Identifier: MIT\u000A// =============================================================\u000A#include <CL/sycl.hpp>\u000A\u000ASYCL_EXTERNAL extern \"C\" unsigned RtlByteswap(unsigned x) {\u000A  return x << 16 | x >> 16; \u000A}\u000A"}, {"path":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load512bit_v5/lib/lib_rtl_model_add.cpp", "name":"lib_rtl_model_add.cpp", "has_active_debug_locs":false, "absName":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load512bit_v5/lib/lib_rtl_model_add.cpp", "content":"//==============================================================\u000A// Copyright Intel Corporation\u000A//\u000A// SPDX-License-Identifier: MIT\u000A// =============================================================\u000A\u000A/*\u000A###############################\u000A## Created: Intel Corporation \u000A##          Christian Faerber\u000A##          PSG CE EMEA TS-FAE \u000A##          June 2022\u000A###############################\u000A*/\u000A\u000A#include <CL/sycl.hpp>\u000A\u000ASYCL_EXTERNAL extern \"C\" unsigned AdderUint(unsigned int a, unsigned int b) {\u000A  return a + b; \u000A}\u000A"}, {"path":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load512bit_v5/lib/lib_sycl.cpp", "name":"lib_sycl.cpp", "has_active_debug_locs":false, "absName":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load512bit_v5/lib/lib_sycl.cpp", "content":"//==============================================================\u000A// Copyright Intel Corporation\u000A//\u000A// SPDX-License-Identifier: MIT\u000A// =============================================================\u000A#include <CL/sycl.hpp>\u000A#include <sycl/ext/intel/fpga_extensions.hpp>\u000A\u000A\u000ASYCL_EXTERNAL float SyclSquare(float x) { return x * x; }\u000ASYCL_EXTERNAL float SyclSqrt(float x) { return sqrt(x); }\u000ASYCL_EXTERNAL int SyclMult(int x, int y) { return x * y; }\u000A\u000A#define N 16\u000A\u000ASYCL_EXTERNAL std::array<int, 16> SyclBubbleSort(\u000A        std::array<int, 16> x\u000A){\u000A\u000A        // Input registers\u000A        int a[N];\u000A        \u000A        #pragma unroll\u000A        for (int i = 0; i < N; i++)\u000A                a[i] = x[i];\u000A\u000A        // bubble sort\u000A        int tmp = 0;\u000A        \u000A        #pragma unroll\u000A        for (int i = 0; i < N; ++i) {\u000A            #pragma unroll\u000A            for (int j = 0; j < N - i - 1; ++j) {\u000A                if (a[j] > a[j + 1]) {\u000A                    tmp = a[j];\u000A                    a[j] = a[j + 1];\u000A                    a[j + 1] = tmp;\u000A                }\u000A            }\u000A        }\u000A\u000A        // Output registers\u000A        std::array<int, 16> a0;\u000A        \u000A        #pragma unroll\u000A        for (int i = 0; i < N; i++)\u000A                a0[i] = a[i];\u000A    \u000A        return a0;\u000A}\u000A\u000A"}, {"path":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load512bit_v5/main.cpp", "name":"main.cpp", "has_active_debug_locs":false, "absName":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load512bit_v5/main.cpp", "content":"/*\u000A###############################\u000A## Created: Eric Stange\u000A##          TU Dresden\u000A##          January 2023\u000A## \u000A## Used template from:\u000A##          Intel Corporation \u000A##          Christian Faerber\u000A##          PSG CE EMEA TS-FAE \u000A##          June 2022\u000A###############################\u000A\u000A* This is a hashbased group count implementation using the linear probing approach.\u000A* The Intel Intrinsics from the previous AVX512-based implementation were re-implemented without AVX512.\u000A* This code is intended to be able to run in parallel with the Intel OneAPI on FPGAs.\u000A*/\u000A////////////////////////////////////////////////////////////////////////////////\u000A////////////////////////////////////////////////////////////////////////////////\u000A//\tOVERVIEW about functions in kernel.cpp\u000A//\u000A//\tLinearProbingFPGA_variant1() == SoA_v1 -- SIMD for FPGA function v1 -  without aligned_start; version descbribed in paper\u000A// \tLinearProbingFPGA_variant2() == SoA_v2 -- SIMD for FPGA function v2 - first optimization: using aligned_start\u000A//\tLinearProbingFPGA_variant3() == SoA_v3 -- SIMD for FPGA function v3 - with aligned start and approach of using permutexvar_epi32\u000A//\tLinearProbingFPGA_variant4() == SoAoV_v1 -- SIMD for FPGA function v4 - use a vector with elements of type <fpvec<Type, regSize> as hash_map structure \"around\" the registers\u000A// \tLinearProbingFPGA_variant5() == SoA_conflict_v1 -- SIMD for FPGA function v5 - \tsearch in loaded data register for conflicts and add the sum of occurences per element to countVec instead of \u000A//\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tprocess each item individually, even though it occurs multiple times in the currently loaded data\t\t\u000A// \u000A////////////////////////////////////////////////////////////////////////////////\u000A////////////////////////////////////////////////////////////////////////////////\u000A#include <stdio.h>\u000A#include <stdlib.h>\u000A#include <sys/types.h>\u000A#include <time.h>\u000A#include <iostream>\u000A#include <chrono>\u000A#include <algorithm>\u000A#include <array>\u000A#include <iomanip>\u000A#include <numeric>\u000A#include <vector>\u000A#include <time.h>\u000A#include <tuple>\u000A#include <utility>\u000A\u000A#include <CL/sycl.hpp>\u000A#include <sycl/ext/intel/fpga_extensions.hpp>\u000A\u000A// Time\u000A#include <sys/time.h>\u000A// Sleep\u000A#include <unistd.h>\u000A\u000A#include \"../config/global_settings.hpp\"\u000A#include \"kernel.hpp\"\u000A#include \"../helper/helper_main.hpp\"\u000A\u000A\u000Ausing namespace sycl;\u000Ausing namespace std::chrono;\u000A\u000A////////////////////////////////////////////////////////////////////////////////\u000A//// Board globals. Can be changed from command line.\u000A// default to values in pac_s10_usm BSP\u000A                         \u000A#ifndef DDR_CHANNELS\u000A#define DDR_CHANNELS 4\u000A#endif\u000A\u000A#ifndef DDR_WIDTH\u000A#define DDR_WIDTH 64 // bytes (512 bits)\u000A#endif\u000A\u000A#ifndef PCIE_WIDTH\u000A#define PCIE_WIDTH 64 // bytes (512 bits)\u000A#endif\u000A\u000A#ifndef DDR_INTERLEAVED_CHUNK_SIZE\u000A#define DDR_INTERLEAVED_CHUNK_SIZE 4096 // bytes\u000A#endif\u000A\u000Aconstexpr size_t kDDRInterleavedChunkSize = DDR_INTERLEAVED_CHUNK_SIZE;\u000A\u000A////////////////////////////////////////////////////////////////////////////////\u000A////////////////////////////////////////////////////////////////////////////////\u000A\u000A////////////////////////////////////////////////////////////////////////////////\u000A//// Forward declare functions\u000Atemplate<typename T>\u000Abool validate(T *in_host, T *out_host, size_t size);\u000Avoid exception_handler(exception_list exceptions);\u000A////////////////////////////////////////////////////////////////////////////////\u000A////////////////////////////////////////////////////////////////////////////////\u000A\u000A// main\u000Aint  main(int argc, char** argv){\u000A\u000A    // make default input size enough to hide overhead\u000A    #ifdef FPGA_EMULATOR\u000A    long size = kDDRInterleavedChunkSize * 4;\u000A    #else\u000A    long size = kDDRInterleavedChunkSize * 16384;\u000A    #endif\u000A\u000A    // the device selector\u000A    #ifdef FPGA_EMULATOR\u000A    ext::intel::fpga_emulator_selector selector;\u000A    #else\u000A    ext::intel::fpga_selector selector;\u000A    #endif\u000A\u000A    // create the device queue\u000A    // auto props = property_list{property::queue::enable_profiling()};\u000A    auto props = property_list{};\u000A    queue q(selector, exception_handler, props);\u000A\u000A    // make sure the device supports USM device allocations\u000A    device d = q.get_device();\u000A    if (!d.get_info<info::device::usm_device_allocations>()) {\u000A        std::cerr << \"ERROR: The selected device does not support USM device\"\u000A                << \" allocations\\n\";\u000A        std::terminate();\u000A    }\u000A    if (!d.get_info<info::device::usm_host_allocations>()) {\u000A        std::cerr << \"ERROR: The selected device does not support USM host\"\u000A                << \" allocations\\n\";\u000A        std::terminate();\u000A    }\u000A\u000A    // print size of local memory on used FPGA\u000A    std::cout << \"Local Memory Size on FPGA: \"\u000A              << q.get_device().get_info<sycl::info::device::local_mem_size>()\u000A              << std::endl;\u000A\u000A    /**\u000A     * calculate parameters for memory allocation\u000A     *\u000A     * If a second parameter is passed when running the main.fpga file, \u000A     * use this as \"size\", otherwise define the parameter \"size\" using the value of\u000A     * variable dataSize, which is defined in global_settings.hpp.\u000A    */ \u000A    if ( argc != 2 ) { // argc should be 2 for correct execution\u000A        size = dataSize;\u000A\t} else {\u000A\t\tsize = atoi(argv[1]);\u000A\t}\u000A    printf(\"Input vector length (atoi(argv[1])): %zd \\n\", size);\u000A\u000A    size_t number_CL_buckets = 0;\u000A    size_t number_CL = 0;\u000A\t\u000A\tif(size % (4096) == 0)\u000A\t{\u000A\t\tnumber_CL_buckets = size / (4096);\u000A\t}\u000A\telse \u000A\t{\u000A\t\tnumber_CL_buckets = size / (4096) + 1;\u000A\t}\u000A\t\u000A    number_CL = number_CL_buckets * (4096/multiplier);\u000A    \u000A\tprintf(\"Number CL buckets: %zd \\n\", number_CL_buckets);\u000A    printf(\"Number CLs: %zd \\n\", number_CL);\u000A\u000A    // print global settings\u000A    std::cout <<\"==============================================\"<<std::endl;\u000A    std::cout <<\"============= Program Start ==================\"<<std::endl; \u000A    std::cout <<\"==============================================\"<<std::endl;    \u000A    std::cout << \"Global configuration:\"<<  std::endl;\u000A    std::cout << \"distinctValues | scale-facor | dataSize : \"<<distinctValues<<\" | \"<<scale<<\" | \"<<dataSize<< std::endl;\u000A    // print hashsize of current settings\u000A    std::cout << \"Configured HSIZE : \" << HSIZE << std::endl;\u000A    std::cout << \"Configured DATATYPE within registers : \" << typeid(Type).name() << std::endl;\u000A    std::cout << \"Configured register size (regSize) for data transfer : \" << regSize << \" byte (= \" << (regSize*8) << \" bit)\" << std::endl;\u000A   \u000A    // Define for Allocate input/output data in pinned host memory\u000A    // Used in all three tests, for convenience\u000A    Type *arr_h, *arr_d; \u000A    Type *hashVec_h, *hashVec_d;\u000A    Type *countVec_h, *countVec_d;\u000A    \u000A\u000A////////////////////////////////////////////////////////////////////////////////\u000A////////////////////////////////////////////////////////////////////////////////\u000A//// Forward declare LinearProbingFPGA_variant5()\u000A    std::cout <<\"==============================================\"<<std::endl;\u000A    std::cout <<\"==============================================\"<<std::endl;\u000A\tprintf(\"\\n \\n ### START of Linear Probing for FPGA - SIMD Variant 5 (SoA_conflict_v1) ### \\n\\n\");\u000A\u000A    // Host buffer \u000A    if ((arr_h = malloc_host<Type>(number_CL*multiplier, q)) == nullptr) {\u000A        std::cerr << \"ERROR: could not allocate space for 'arr_h'\\n\";\u000A        std::terminate();\u000A    }\u000A    if ((hashVec_h = malloc_host<Type>(HSIZE, q)) == nullptr) {\u000A        std::cerr << \"ERROR: could not allocate space for 'hashVec_h'\\n\";\u000A        std::terminate();\u000A    }\u000A    if ((countVec_h = malloc_host<Type>(HSIZE, q)) == nullptr) {\u000A        std::cerr << \"ERROR: could not allocate space for 'countVec_h'\\n\";\u000A        std::terminate();\u000A    }  \u000A\u000A    // Device buffer  \u000A    if ((arr_d = malloc_device<Type>(number_CL*multiplier, q)) == nullptr) {\u000A        std::cerr << \"ERROR: could not allocate space for 'arr_d'\\n\";\u000A        std::terminate();\u000A    }\u000A    if ((hashVec_d = malloc_device<Type>(HSIZE, q)) == nullptr) {\u000A        std::cerr << \"ERROR: could not allocate space for 'hashVec_d'\\n\";\u000A        std::terminate();\u000A    }\u000A    if ((countVec_d = malloc_device<Type>(HSIZE, q)) == nullptr) {\u000A        std::cerr << \"ERROR: could not allocate space for 'countVec_d'\\n\";\u000A        std::terminate();\u000A    } \u000A\u000A    // check if memory for input array and HashTable (hashVec and countVec) is allocated correctly (on host)\u000A    if (arr_h != NULL) {\u000A        std::cout << \"Memory allocated - \" << dataSize << \" values, between 1 and \" << distinctValues << std::endl;\u000A    } else {\u000A        std::cout << \"Memory not allocated!\" << std::endl;\u000A    }\u000A    if (hashVec_h != NULL ||  countVec_h != NULL) {\u000A        std::cout << \"HashTable allocated - \" <<HSIZE<< \" values\" << std::endl;\u000A    } else {\u000A        std::cout << \"HashTable not allocated\" << std::endl;\u000A    }\u000A\u000A    // Init input buffer\u000A    generateData<Type>(arr_h);    \u000A    std::cout <<\"Generation of initial data done.\"<< std::endl; \u000A\u000A    // Copy input host buffer to input device buffer\u000A    q.memcpy(arr_d, arr_h, number_CL*multiplier * sizeof(Type));\u000A    q.wait();\t\u000A\u000A    // init HashMap\u000A    initializeHashMap(hashVec_h,countVec_h);\u000A    \u000A    // Copy with zero initialized HashMap (hashVec, countVec) from host to device\u000A    q.memcpy(hashVec_d, hashVec_h, HSIZE * sizeof(Type));\u000A    q.wait();\u000A    q.memcpy(countVec_d, countVec_h, HSIZE * sizeof(Type));\u000A    q.wait();\u000A\u000A    // track timing information, in ms\u000A    double pcie_time_v5=0.0;\u000A\u000A//SIMD for FPGA function v5 (SoA_conflict_v1)\u000A    try {\u000A        ////////////////////////////////////////////////////////////////////////////\u000A        std::cout <<\"==============================\"<<std::endl;\u000A        std::cout <<\"Kernel-Start : LinearProbingFPGA_variant5() == SoA_conflict_v1 -- SIMD for FPGA Variant v5:\"<<std::endl;\u000A        std::cout <<\"Running on FPGA Hardware with a dataSize of \" << dataSize << \" values!\" << std::endl;\u000A\u000A        // dummy run to program FPGA, dont care first run for measurement\u000A        LinearProbingFPGA_variant5(q, arr_d, hashVec_d, countVec_d, number_CL*multiplier);  //difference value for size parameter compared to v1-v4\u000A\u000A        // Re-Initialize HashMap after dummy run\u000A        initializeHashMap(hashVec_h,countVec_h);\u000A        q.memcpy(hashVec_d, hashVec_h, HSIZE * sizeof(Type));\u000A        q.wait();\u000A        q.memcpy(countVec_d, countVec_h, HSIZE * sizeof(Type));\u000A        q.wait();\u000A\u000A        // measured run on FPGA\u000A        auto begin_v5 = std::chrono::high_resolution_clock::now();\u000A        LinearProbingFPGA_variant5(q, arr_d, hashVec_d, countVec_d, number_CL*multiplier);  //difference value for size parameter compared to v1-v4\u000A        auto end_v5 = std::chrono::high_resolution_clock::now();\u000A        duration<double, std::milli> diff_v5 = end_v5 - begin_v5;\u000A\u000A        std::cout<<\"Kernel runtime of function LinearProbingFPGA_variant5(): \"<< (diff_v5.count()) << \" ms.\" <<std::endl;\u000A        std::cout <<\"==============================\"<<std::endl;\u000A        pcie_time_v5=diff_v5.count();\u000A        ////////////////////////////////////////////////////////////////////////////\u000A    } \u000A    catch (sycl::exception const& e) {\u000A        std::cout << \"Caught a synchronous SYCL exception: \" << e.what() << \"\\n\";\u000A        std::terminate();\u000A    }   \u000A\u000A    // Copy output device buffer to output host buffer \u000A    q.memcpy(hashVec_h, hashVec_d, HSIZE * sizeof(Type));\u000A    q.wait();  \u000A    q.memcpy(countVec_h, countVec_d, HSIZE * sizeof(Type));\u000A    q.wait();  \u000A\u000A    /**\u000A     * Test print to detect the following error, which has occurred irregularly in the past. \u000A     * Element Validation\u000A     * ERROR   Count           76      has a count of 1249992  but should have a count of 1249994\u000A     * Element Validation found 1 Error\u000A     * ==============================\u000A     * i || hashVec || countVec ||\u000A     * 0 || 76 || 1249992 || 1249992\u000A     * 1 || 76 || 2 || 2\u000A    */\u000A    /*\u000A    std::cout<<\"i || hashVec || countVec ||\"<<std::endl;\u000A    for(int i=0; i<HSIZE; i++) {\u000A        std::cout<<i<<\" || \"<<hashVec_d[i]<<\" || \"<<countVec_d[i]<<\" || \"<<countVec_h[i]<<std::endl;\u000A    }  \u000A    */\u000A    \u000A    std::cout << \"Value in variable dataSize: \" << dataSize << std::endl;\u000A    std::cout<< \" \" <<std::endl;\u000A\u000A    // check result for correctness\u000A    validate(hashVec_h, countVec_h);\u000A//  validate_element(arr_h, hashVec_h, countVec_h);\u000A    std::cout<< \" \" <<std::endl;\u000A\u000A    // free USM memory\u000A    sycl::free(arr_h, q);\u000A    sycl::free(hashVec_h, q);\u000A    sycl::free(countVec_h, q);\u000A    \u000A    sycl::free(arr_d, q);\u000A    sycl::free(hashVec_d, q);\u000A    sycl::free(countVec_d, q);   \u000A\u000A    // print result\u000A    std::cout <<\"Final Evaluation of the Throughput: \"<<std::endl;\u000A    double input_size_mb_v5 = size * sizeof(Type) * 1e-6;\u000A\tstd::cout <<\"Input_size_mb: \"<< input_size_mb_v5 <<std::endl;\u000A    std::cout <<\"HOST-DEVICE Throughput: \"<< (input_size_mb_v5 / (pcie_time_v5 * 1e-3)) << \" MB/s\\n\";\u000A\u000A    std::cout <<\" ### End of Linear Probing for FPGA - SIMD Variant 5 ### \"<<std::endl;\u000A    std::cout <<\"==============================================\"<<std::endl;\u000A    std::cout <<\"==============================================\"<<std::endl;\u000A//// end of LinearProbingFPGA_variant5()\u000A////////////////////////////////////////////////////////////////////////////////\u000A}\u000A// end of main()\u000A\u000Avoid exception_handler (exception_list exceptions) {                     \u000A  for (std::exception_ptr const& e : exceptions) {\u000A    try {\u000A        std::rethrow_exception(e);\u000A    } catch(sycl::exception const& e) {\u000A        std::cout << \"Caught asynchronous SYCL exception:\\n\"\u000A            << e.what() << std::endl;\u000A    }\u000A  }\u000A}"}, {"path":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/primitives/primitives.hpp", "name":"primitives.hpp", "has_active_debug_locs":false, "absName":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/primitives/primitives.hpp", "content":"#ifndef PRIMITIVES_HPP__\u000A#define PRIMITIVES_HPP__\u000A\u000A#include <array>\u000A#include \"../config/global_settings.hpp\"\u000A\u000A/**\u000A * This file contains the scalar primitves of the Intel Intrinsics, which are used \u000A * in the own AVX512-implementations of the hashbased group_count.\u000A * These functions will be used to run the logic of the AVX512 implementations \u000A * on a FPGA within the Intel DevCloud.\u000A *\u000A * Some of these functions are adapted to the peculiarities of our implementation. \u000A * This is usually due to the goal of simplified data processing. \u000A * In some cases, however, the logic of the implemented LinearProbing algorithms required a \"special solution\".\u000A*/\u000A\u000Atemplate<typename T, int B>\u000Astruct fpvec {\u000A    [[intel::fpga_register]] std::array<T, (B/sizeof(T))> elements;\u000A};\u000A\u000A/* // print a fpvec<T> result register\u000A\tfor (int i=0; i<(64/sizeof(T)); i++) {\u000A\t\tstd::cout << reg.elements[i] << \" \";\u000A\t} \u000A*/\u000A\u000A/**\t#1\u000A * serial primitive for Intel Intrinsic:\u000A * _mm512_setzero_epi32\u000A */\u000Atemplate<typename T, int B>\u000Afpvec<T,B> setzero() {\u000A\tauto reg = fpvec<T,B>{};\u000A\tType zero = 0;\u000A\t#pragma unroll\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\treg.elements[i] = zero;\u000A\t}\u000A\treturn reg;\u000A} \u000A\u000A/**\t#2\u000A * serial primitive for Intel Intrinsic:\u000A * __m512i _mm512_setr_epi32 (int e15, int e14, int e13, int e12, \u000A * int e11, int e10, int e9, int e8, int e7, int e6, int e5, int e4, int e3, \u000A * int e2, int e1, int e0)\u000A * \u000A * function will (currently) only be working for arrys with 16 elements of 32bit integers!\u000A */\u000A/** Not used in current code version --> due to limitations regarding dynamic change of size and amount of elements\u000Atemplate<typename T, int B>\u000Afpvec<T> setr_16slot(uint32_t e15, uint32_t e14, uint32_t e13, uint32_t e12, uint32_t e11, uint32_t e10, uint32_t e9,\u000A\tuint32_t e8, uint32_t e7, uint32_t e6, uint32_t e5, uint32_t e4, uint32_t e3, uint32_t e2, uint32_t e1, uint32_t e0) {\u000A\tauto reg = fpvec<T>{};\u000A\treg.elements[0] = e0;\u000A\treg.elements[1] = e1;\u000A\treg.elements[2] = e2;\u000A\treg.elements[3] = e3;\u000A\treg.elements[4] = e4;\u000A\treg.elements[5] = e5;\u000A\treg.elements[6] = e6;\u000A\treg.elements[7] = e7;\u000A\treg.elements[8] = e8;\u000A\treg.elements[9] = e9;\u000A\treg.elements[10] = e10;\u000A\treg.elements[11] = e11;\u000A\treg.elements[12] = e12;\u000A\treg.elements[13] = e13;\u000A\treg.elements[14] = e14;\u000A\treg.elements[15] = e15;\u000A\treturn reg;\u000A}\u000A*/\u000A\u000A/**\t#3\u000A* serial primitive for Intel Intrinsic:\u000A* __m512i _mm512_set1_epi32 (int a)\u000A*\u000A* The original Intrinsic was only for 32-bit integers.\u000A* This implemenation is working with uint32_t & uint64_t, etc.\u000A* But be careful with matching ratio of <Type, B> and related T value which is overhanded to the function!\u000A*/\u000Atemplate<typename T, int B>\u000Afpvec<T,B> set1(T value) {\u000A\tauto reg = fpvec<T,B>{};\u000A\t#pragma unroll\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\treg.elements[i] = value;\u000A\t}\u000A\treturn reg;\u000A}\u000A\u000A/**\t#4\u000A* serial primitive for Intel Intrinsic:\u000A* __mmask16 _cvtu32_mask16 (unsigned int a)\u000A* original description: \"Convert integer value a into an 16-bit mask, and store the result in k.\"*\u000A*/\u000Atemplate<typename T, int B>\u000Afpvec<T,B> cvtu32_mask16(T n) {\u000A\tauto reg = fpvec<T,B>{};\u000A\tint lastElement = ((B/sizeof(T))-1);\u000A\t#pragma unroll\u000A\twhile (lastElement >= 0) {\u000A         // storing remainder in array\u000A        reg.elements[lastElement] = (n >> lastElement) & 0x1;;\u000A\t\tlastElement = lastElement-1;\u000A    }\u000A\treturn reg;\u000A}\u000A\u000A/**\t#4.1\u000A* serial primitive adaption of Intel Intrinsic:\u000A* __mmask16 _cvtu32_mask16 (unsigned int a)\u000A* Function creates array with elements of <fpvec<Type,B>; every element consists of a <fpvec<Type,B> register with all 0 except at position i\u000A* 10000000\u000A* 01000000\u000A* 00100000\u000A* 00010000\u000A* ...\u000A* Function automatically adjusts all sizes depending on the data type and the regSize parameter.\u000A*/\u000Atemplate<typename T, int B>\u000Astd::array<fpvec<T, B>, (B/sizeof(T))> cvtu32_create_writeMask_Matrix() {\u000A\tType zero = 0;\u000A\tType one = 1;\u000A\tstd::array<fpvec<Type, B>, (B/sizeof(T))> result;\u000A\u000A\t#pragma unroll\u000A\tfor(Type i = 0; i < (B/sizeof(T)); i++){\u000A\t\tauto tmp = fpvec<T,B>{};\u000A\t\t#pragma unroll\u000A\t\tfor (int j=0; j<(B/sizeof(T)); j++) {\u000A\t\t\ttmp.elements[j] = zero;\u000A\t\t}\u000A\t\ttmp.elements[i] = one;\u000A\t\tresult[i] = tmp;\u000A\t}\u000A\treturn result;\u000A}\u000A\u000A/**\t#5\u000A* serial primitive for two Intel Intrinsics:\u000A* __m512i _mm512_maskz_loadu_epi32 (__mmask16 k, void const* mem_addr)\u000A* __m512i _mm512_mask_loadu_epi32 (__m512i src, __mmask16 k, void const* mem_addr)\u000A* _mm512_maskz_loadu_epi32\t:\toriginal description: \"Load packed 32-bit integers from memory \u000A*\t\t\t\t\t\t\t\tinto dst using zeromask k (elements are zeroed out when the \u000A*\t\t\t\t\t\t\t\tcorresponding mask bit is not set). mem_addr does not need to \u000A*\t\t\t\t\t\t\t\tbe aligned on any particular boundary.\"\u000A* _mm512_mask_loadu_epi32\t:\toriginal description: \"Load packed 32-bit integers from memory \u000A*\t\t\t\t\t\t\t\tinto dst using writemask k (elements are copied from src when \u000A*\t\t\t\t\t\t\t\tthe corresponding mask bit is not set). \u000A*\t\t\t\t\t\t\t\tmem_addr does not need to be aligned on any particular boundary.\"\u000A*\u000A* customized loadu-function:\u000A* @param writeMask : if bit is set to \"1\" load related item from data\u000A* @param data : array which contains the data which should be loaded\u000A* @param startIndex : first index-position of data from where the data should be loaded\u000A*/\u000Atemplate<typename T, int B>\u000Afpvec<T, B> mask_loadu(fpvec<T,B>& writeMask, std::array<Type, HSIZE>& data, uint32_t startIndex) {\u000A\tauto reg = fpvec<T,B>{};\u000A\t#pragma unroll 16\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\tif (writeMask.elements[i] == 1) {\u000A\t\t\t// old reg.elements[i] = data[(startIndex+i)%HSIZE];\u000A\t\t\treg.elements[i] = data[startIndex+i];\u000A\t\t}\u000A\t}\u000A\treturn reg;\u000A}\u000A\u000A/**\t#5.1\u000A * \u000A * Adapted version of function #5, to load from the buffer, which is used in LinearProbing_v5()\u000A * The used buffer is of type: std::array<Type, elements_per_inner_register>\t<-- parameter are defined in global_settings.hpp\u000A*/\u000Atemplate<typename T, int B>\u000Afpvec<T, B> mask_loadu_from_buffer(fpvec<T,B>& writeMask, std::array<Type, elements_per_inner_register>& data, uint32_t startIndex) {\u000A\tauto reg = fpvec<T,B>{};\u000A\t#pragma unroll\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\tif (writeMask.elements[i] == 1) {\u000A\t\t\t// old reg.elements[i] = data[(startIndex+i)%HSIZE];\u000A\t\t\treg.elements[i] = data[startIndex+i];\u000A\t\t}\u000A\t}\u000A\treturn reg;\u000A}\u000A\u000A/**\t#6\u000A* serial primitive for Intel Intrinsic:\u000A* __mmask16 _mm512_mask_cmpeq_epi32_mask (__mmask16 k1, __m512i a, __m512i b)\u000A* original description: \"Compare packed 32-bit integers in a and b for equality, and store the results in mask vector k \u000A* using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\"\u000A*/\u000Atemplate<typename T, int B>\u000Afpvec<T,B> mask_cmpeq_epi32_mask(fpvec<T,B>& zeroMask, fpvec<T,B>& a, fpvec<T,B>& b) {\u000A\tauto reg = fpvec<T,B>{};\u000A\t#pragma unroll\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\tif (zeroMask.elements[i] == 1) {\u000A\t\t\tif (a.elements[i] == b.elements[i]) {\u000A\t\t\t\treg.elements[i] = 1;\u000A\t\t\t}\t\u000A\t\t}\t\u000A\t}\u000A\treturn reg;\u000A}\u000A\u000A/**\t#7\u000A* serial primitive for Intel Intrinsic:\u000A* __m512i _mm512_mask_add_epi32 (__m512i src, __mmask16 k, __m512i a, __m512i b)\u000A* original description: \"Add packed 32-bit integers in a and b, and store the results in dst using writemask k \u000A* (elements are copied from src when the corresponding mask bit is not set).\"\u000A*/\u000Atemplate<typename T, int B>\u000Afpvec<T,B> mask_add_epi32(fpvec<T,B>& src, fpvec<T,B>& writeMask, fpvec<T,B>& a, fpvec<T,B>& b) {\u000A\tauto reg = fpvec<T,B>{};\u000A\t#pragma unroll\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\tif (writeMask.elements[i] == 1) {\u000A\t\t\treg.elements[i] = a.elements[i] + b.elements[i];\u000A\t\t}\u000A\t\telse {\u000A\t\t\treg.elements[i] = src.elements[i];\u000A\t\t}\u000A\t}\u000A\treturn reg;\u000A}\u000A\u000A/**\t#8\u000A* serial primitive for Intel Intrinsic:\u000A* void _mm512_mask_storeu_epi32 (void* mem_addr, __mmask16 k, __m512i a)\u000A* original description: \"Store packed 32-bit integers from a (=data) into memory using writemask k. \u000A* mem_addr does not need to be aligned on any particular boundary.\"\u000A*\u000A* customized store  - function:\u000A* @param result : array, in which the data is stored, if related bit of writeMask is set to \"1\"\u000A* @param startIndex : first index - position of data from where the data should be stored\u000A* @param writeMask : if bit is set to \"1\" -> store related item from data into result array\u000A* @param data : register-array which contains the data that should be stored\u000A*/\u000Atemplate<typename T, int B>\u000Avoid mask_storeu_epi32(std::array<Type, HSIZE>& result, uint32_t startIndex, fpvec<T,B>& writeMask, fpvec<T,B>& data) {\u000A\t#pragma unroll 16\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\tif (writeMask.elements[i] == 1) {\u000A\t\t\t// result[(startIndex+i)%HSIZE] = data.elements[i];\u000A\t\t\tresult[startIndex+i] = data.elements[i];\u000A\t\t}\u000A\t}\u000A}\u000A\u000A/**\t#9\u000A* serial primitive for Intel Intrinsic:\u000A* int _mm512_mask2int (__mmask16 k1)\u000A* original description: \"Converts bit mask k1 into an integer value, storing the results in dst.\"\u000A* own (simplified implementation):\u000A* \u000A* IMPORTANT: \tThis is an adjustet implementation of the intrinsic mentioned above. \u000A\t\t\t\tThis solution is specially tailored to the logical flow of LinearProbing_v1 - v5 \u000A\t\t\t\tand its functionality is reduced to its necessities.\u000A* @return 1 if at least 1 bit of mask is set;\u000A* @return 0 if no bit of mask is set\u000A*/\u000Atemplate<typename T, int B>\u000AType mask2int(fpvec<T,B>& mask) {\u000A\tType res = 0;\u000A\t#pragma unroll\t\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\tif (mask.elements[i] == 1) {\u000A\t\t\tres = 1;\u000A\t\t}\u000A\t}\u000A\treturn res;\u000A}\u000A\u000A/**\t#9.1\u000A* adaption of Intel Intrinsic:\u000A* int _mm512_mask2int (__mmask16 k1)\u000A* IMPORTANT: \tThis is an own adapted implementation of _mm512_mask2int, which return an uint32_t value\u000A*\t\t\t\tas representation of overhanded mask.\u000A*\t\t\t\tThis function can handle masks up to 32 elements!\u000A*\u000A* @return uint32 value as representation of overhanded mask\u000A* @return 0 if no bit of mask is set\u000A*/\u000Atemplate<typename T, int B>\u000Auint32_t mask2int_uint32_t(fpvec<T,B>& mask) {\u000A\tuint32_t res = 0;\u000A\t#pragma unroll\t\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\tif (mask.elements[i] == 1) {\u000A\t\t\tif (i == 0) {\u000A\t\t\t\tres += 1;\u000A\t\t\t} else {\u000A\t\t\t\tuint32_t tmp = 1;\u000A\t\t\t\t#pragma unroll\u000A\t\t\t\tfor (int j=1; j<=i; j++) {\u000A\t\t\t\t\ttmp = tmp * 2;\u000A\t\t\t\t}\u000A\t\t\t\tres += tmp;\u000A\t\t\t}\u000A\t\t}\u000A\t}\u000A\treturn res;\u000A}\u000A\u000A/**\t#9.2\u000A* adaption of Intel Intrinsic:\u000A* int _mm512_mask2int (__mmask16 k1)\u000A* IMPORTANT: \tThis is an own adapted implementation of _mm512_mask2int, which return an uint64_t value\u000A*\t\t\t\tas representation of overhanded mask.\u000A*\t\t\t\tThis function can handle masks up to 64 elements!\u000A*\u000A* @return uint64_t value as representation of overhanded mask\u000A* @return 0 if no bit of mask is set\u000A*/\u000Atemplate<typename T, int B>\u000Auint64_t mask2int_uint64_t(fpvec<T,B>& mask) {\u000A\tuint64_t res = 0;\u000A\t#pragma unroll\t\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\tif (mask.elements[i] == 1) {\u000A\t\t\tif (i == 0) {\u000A\t\t\t\tres += 1;\u000A\t\t\t} else {\u000A\t\t\t\tuint64_t tmp = 1;\u000A\t\t\t\t#pragma unroll\u000A\t\t\t\tfor (int j=1; j<=i; j++) {\u000A\t\t\t\t\ttmp = tmp * 2;\u000A\t\t\t\t}\u000A\t\t\t\tres += tmp;\u000A\t\t\t}\u000A\t\t}\u000A\t}\u000A\treturn res;\u000A}\u000A\u000A/**\t#10\u000A* serial primitive for Intel Intrinsic:\u000A* __mmask16 _mm512_knot (__mmask16 a)\u000A* original description: \"Compute the bitwise NOT of 16-bit mask a, and store the result in k.\"\u000A*/\u000Atemplate<typename T, int B>\u000Afpvec<T,B> knot(fpvec<T,B>& src) {\u000A\tauto reg = fpvec<T,B>{};\u000A\t#pragma unroll\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\tif (src.elements[i] == 0) {\u000A\t\t\treg.elements[i] = 1;\u000A\t\t}\u000A\t\telse {\u000A\t\t\treg.elements[i] = 0;\u000A\t\t}\u000A\t}\u000A\treturn reg;\u000A}\u000A\u000A/**\t#11\u000A* serial primitive for Built-in Function Provided by GCC:\u000A* int __builtin_clz (unsigned int x)\u000A* original description: \"Built-in Function: int __builtin_clz (unsigned int x)\u000A* Returns the number of leading 0-bits in x, starting at the most significant bit position. \u000A* If x is 0, the result is undefined.\"\u000A*/\u000Atemplate<typename T, int B>\u000AType clz_onceBultin(fpvec<T,B>& src) {\u000A\tType res = 0;\u000A\t#pragma unroll\u000A\tfor (int i=((B/sizeof(T))-1); i>=0; i--) {\u000A\t\tif (src.elements[i]==0) {\u000A\t\t\tres = res+1;\u000A\t\t} else {\u000A\t\t\tbreak;\u000A\t\t}\u000A\t}\u000A\treturn res;\u000A}\u000A\u000A/**\t#12\u000A* serial primitive for Intel Intrinsic:\u000A* __m512i _mm512_load_epi32 (void const* mem_addr)\u000A* original description: \"Load 512-bits (composed of 16 packed 32-bit integers) from memory into dst. \u000A* mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.\"\u000A*\u000A* customized load-function:\u000A* @param data : array which contains the data that should be loaded\u000A* @param startIndex : first index-position of data from where the data should be loaded\u000A*/\u000Atemplate<typename T, int B>\u000Afpvec<T,B> load_epi32(std::array<Type, HSIZE>& data, uint32_t startIndex) {\u000A\tauto reg = fpvec<T,B>{};\u000A\t#pragma unroll\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\treg.elements[i] = data[startIndex+i];\u000A\t}\u000A\treturn reg;\u000A}\u000A\u000A/**\t#13\u000A* serial primitive for Intel Intrinsic:\u000A* __mmask16 _mm512_cmpeq_epi32_mask (__m512i a, __m512i b)\u000A* original description: \"Compare packed 32-bit integers in a and b for equality, and store the results in mask vector k.\"\u000A*/\u000Atemplate<typename T, int B>\u000Afpvec<T,B> cmpeq_epi32_mask(fpvec<T,B>& a, fpvec<T,B>& b) {\u000A\tauto reg = fpvec<T,B>{};\u000A\t#pragma unroll\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\tif (a.elements[i] == b.elements[i]) {\u000A\t\t\treg.elements[i] = 1;\u000A\t\t}\u000A\t\telse {\u000A\t\t\treg.elements[i] = 0;\u000A\t\t}\u000A\t}\u000A\treturn reg;\u000A}\u000A\u000A/**\t#14\u000A* serial primitive for Intel Intrinsic:\u000A* __m512i _mm512_permutexvar_epi32 (__m512i idx, __m512i a)\u000A* original description: \"Shuffle 32-bit integers in a across lanes using the corresponding index in idx, and store the results in dst.\"\u000A*/\u000Atemplate<typename T, int B>\u000Afpvec<T,B> permutexvar_epi32(fpvec<T,B>& idx, fpvec<T,B>& a) {\u000A\tauto reg = fpvec<T,B>{};\u000A\t#pragma unroll\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\tT id = idx.elements[i];\u000A\t\tT value = a.elements[id];\u000A\t\treg.elements[i] = value;\u000A\t}\u000A\treturn reg;\u000A}\u000A\u000A/**\t#15\u000A* serial primitive for Built-in Function Provided by GCC:\u000A* int __builtin_ctz (unsigned int x)\u000A* original description: \"Built-in Function: int __builtin_ctz (unsigned int x)\u000A* Returns the number of trailing 0-bits in x, starting at the least significant bit position. \u000A* If x is 0, the result is undefined.\"\u000A*/\u000Atemplate<typename T, int B>\u000AType ctz_onceBultin(fpvec<T,B>& src) {\u000A\tType res = 0;\u000A\t#pragma unroll\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\tif (src.elements[i]==0) {\u000A\t\t\tres = res+1;\u000A\t\t} else {\u000A\t\t\tbreak;\u000A\t\t}\u000A\t}\u000A\treturn res;\u000A}\u000A\u000A////////////////////////////////////////////////////////////////////////////\u000A////////////////////////////////////////////////////////////////////////////\u000A//// New functions for SoAoV approach only - not in SoA-implementations ////\u000A////////////////////////////////////////////////////////////////////////////\u000A////////////////////////////////////////////////////////////////////////////\u000A\u000A/**\t#16 \u000A* serial primitive for Intel Intrinsic:\u000A* __m512i _mm512_mask_set1_epi32 (__m512i src, __mmask16 k, int a)\u000A* original description: \"Broadcast 32-bit integer a to all elements of dst using \u000A* writemask k (elements are copied from src when the corresponding mask bit is not set).\"\u000A*/\u000Atemplate<typename T, int B>\u000Afpvec<T,B> mask_set1(fpvec<T,B>& src, fpvec<T,B>& writeMask, Type value) {\u000A\tauto reg = fpvec<T,B>{};\u000A\t#pragma unroll\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\tif(writeMask.elements[i] == 1) {\u000A\t\t\treg.elements[i] = value;\u000A\t\t} else {\u000A\t\t\treg.elements[i] = src.elements[i];\u000A\t\t}\t\t\u000A\t}\u000A\treturn reg;\u000A}\u000A\u000A/**\t#17\u000A* serial primitive for Intel Intrinsic:\u000A* void _mm512_store_epi32 (void* mem_addr, __m512i a)\u000A* original description: \"Store 512-bits (composed of 16 packed 32-bit integers) from a into memory. \u000A* mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.\"\u000A*\u000A* customized store  - function:\u000A* @param result : array, in which the data is stored; function store 512, 1024, 1536 or 2048 bits\u000A* @param startIndex : first index - position of data from where the data should be stored\u000A* @param data : register-array which contains the data that should be stored\u000A*/\u000Atemplate<typename T, int B>\u000Avoid store_epi32(Type* result, uint32_t startIndex, fpvec<T,B>& data) {\t\t\t\t// We use THIS function only for the SoAoV approach, to store back the vectors to the global memory\u000A\t#pragma unroll\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\tresult[(startIndex+i)] = data.elements[i];\u000A\t}\u000A}\u000A\u000A\u000A///////////////////////////////////////////////////////////////////////////////////////////\u000A///////////////////////////////////////////////////////////////////////////////////////////\u000A////////// Functions to load 512bit or 2048 bit onto FPGA within one clock cycle //////////\u000A///////////////////////////////////////////////////////////////////////////////////////////\u000A///////////////////////////////////////////////////////////////////////////////////////////\u000A\u000A/**\t#18\u000A* Own function to load 1*512bit with one DMA within one clock cycle from global memory onto FPGA\u000A*/\u000Atemplate<typename T, int B>\u000Afpvec<T,B> load(T* p, int i_cnt) {\u000A\tconst int i_localConst = i_cnt;\u000A    auto reg = fpvec<T,B>{};\u000A    #pragma unroll\u000A    for (uint idx = 0; idx < (B/sizeof(T)); idx++) {\u000A          reg.elements[idx] = p[idx + i_localConst * (B/sizeof(T))];\u000A    }\u000A    return reg;\u000A}\u000A\u000A\u000A/**\t#19\u000A* Own function to load 4*512bit (2048bit, 256 byte) (= complete CL (register)) in one clock cycle from input array\u000A* Load complete CL (register) in one clock cycle (same for PCIe and DDR4) \u000A* Function is based on the approach of parallel load with all 4 memory controller \u000A*/\u000Atemplate<typename T, int B>\u000Afpvec<T,B> maxLoad_per_clock_cycle(T* input, size_t kNumLSUs, size_t kValuesPerLSU, const int chunk_idx, const size_t kValuesPerInterleavedChunk, const int chunk_offset) {\u000A\tauto reg = fpvec<T,B>{};\u000A\t// Load complete CL in one clock cycle, (same for PCIe and DDR4)\u000A\t#pragma unroll\u000A\tfor (size_t l = 0; l < kNumLSUs; l++) {\u000A\t\t#pragma unroll\u000A\t\tfor (size_t k = 0; k < kValuesPerLSU; k++) {\u000A\t\t\t\t\t\t\t\u000A\t\t\tconst int idx = (chunk_idx*kValuesPerInterleavedChunk*kNumLSUs)\u000A\t\t\t\t\t\t\t+ (chunk_offset*kValuesPerLSU)\u000A\t\t\t\t\t\t\t+ (l*kValuesPerInterleavedChunk)\u000A\t\t\t\t\t\t\t+ k;\u000A\u000A\t\t\treg.elements[l*kValuesPerLSU+k] = input[idx];\u000A\t\t}\u000A\t}\t\u000A    return reg;\u000A}\u000A\u000A////////////////////////////////////////////////////////////////////////////////////////\u000A////////////////////////////////////////////////////////////////////////////////////////\u000A////////// New functions to calculate overflow -  independant of elementCount //////////\u000A////////////////////////////////////////////////////////////////////////////////////////\u000A////////////////////////////////////////////////////////////////////////////////////////\u000A\u000A/**\t#20\u000A* Own function to create the overflow_correction_mask\u000A*/\u000Atemplate<typename T, int B>\u000Afpvec<T,B> createOverflowCorrectionMask(T oferflowUnsigned) {\u000A\tauto reg = fpvec<T,B>{};\u000A\tconst int overflow = (B/sizeof(T)) - oferflowUnsigned;\u000A\tType one = 1;\u000A\tType zero = 0;\u000A\t#pragma unroll\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\tif (i<overflow) {\u000A\t\t\treg.elements[i] = one;\u000A\t\t}\u000A\t\telse {\u000A\t\t\treg.elements[i] = zero;\u000A\t\t}\t\t\u000A\t}\u000A\treturn reg;\u000A} \u000A\u000A/**\t#21\u000A* Own function to create the cutlow_mask\u000A*/\u000Atemplate<typename T, int B>\u000Afpvec<T,B> createCutlowMask(T cutlowUnsigned) {\u000A\tauto reg = fpvec<T,B>{};\u000A\tconst int cutlow_const = (B/sizeof(T)) - cutlowUnsigned;\u000A\tType one = 1;\u000A\tType zero = 0;\u000A\t#pragma unroll\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\tif (i<cutlow_const) {\u000A\t\t\treg.elements[i] = zero;\u000A\t\t}\u000A\t\telse {\u000A\t\t\treg.elements[i] = one;\u000A\t\t}\t\t\u000A\t}\u000A\treturn reg;\u000A} \u000A\u000A////////////////////////////////////////////////////////////////////////////////////////\u000A////////////////////////////////////////////////////////////////////////////////////////\u000A////////////  New functions for LinearProbing_v5 == soa_conflict_v1  ///////////////////\u000A////////////////////////////////////////////////////////////////////////////////////////\u000A////////////////////////////////////////////////////////////////////////////////////////\u000A\u000A/**\t#22\u000A* serial primitive for Intel Intrinsic:\u000A* __m512i _mm512_conflict_epi32 (__m512i a)\u000A* original description: \"Test each 32-bit element of a for equality with all other elements in a closer to the least significant bit. Each element's comparison forms a zero extended bit vector in dst.\"\u000A* \u000A* customized conflict_epi32 - function:\u000A* This function check whether an element is already in the vector. \u000A* Only elements with a lower index are checked. \u000A* As a result, element 0 in the vector never has a conflict. The bits for each element are then set accordingly. \u000A* IMPORTANT: At the point where a conflict is found, the position of the first occurrence is written! \u000A* IMPORTANT: The position is specified from 1 to #elementCount (NOT 0-n-1) !!\u000A*\u000A* adjustment against original Intel Intrinsic:\u000A* 104 71 106 116 82 128 75 109 42 78 59 44 115 124 100 71 --> 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 \u000A* 104 71  71 116 82  71 75 109 42 78 59 44 115 124 100 71 --> 0 0 2 0 0 2 0 0 0 0 0 0 0 0 0 2 \u000A*/\u000Atemplate<typename T, int B>\u000Afpvec<T,B> conflict_epi32(fpvec<T,B>& a) {\u000A\tauto reg = fpvec<T,B>{};\u000A\t#pragma unroll\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\tType currentElement = a.elements[i];\u000A\t\t#pragma unroll\u000A\t\tfor (int j=0; j<i; j++) {\u000A\t\t\tif(a.elements[j] == currentElement) {\u000A\t\t\t\treg.elements[i] = (Type)(j+1);\u000A\t\t\t\tj=i;\t\u000A\t\t\t\tbreak;\t\t\t\u000A\t\t\t}\u000A\t\t}\u000A\t}\t\u000A\treturn reg;\u000A}\u000A\u000A\u000A/**\t#23\u000A* serial primitive for Intel Intrinsic:\u000A* void _mm512_mask_compressstoreu_epi32 (void* base_addr, __mmask16 k, __m512i a)\u000A* original description: \"Contiguously store the active 32-bit integers in a (those with their respective bit set in writemask k) to unaligned memory at base_addr.\"\u000A*\u000A* @param buffer : \u000A* @param writeMask : \u000A* @param data : \u000A*/\u000Atemplate<typename T, int B>\u000Avoid mask_compressstoreu_epi32(std::array<Type, elements_per_inner_register>& buffer, fpvec<T,B>& writeMask, fpvec<T,B>& data) {\u000A\tint buffer_position = 0;\u000A\t#pragma unroll\t\t\t\t\t\t\t\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\tif (writeMask.elements[i] == 1) {\u000A\t\t\tbuffer[buffer_position] = (Type)data.elements[i];\u000A\t\t\tbuffer_position++;\u000A\t\t}\u000A\t}\u000A}\u000A\u000A/**\t#24\u000A* serial primitive for Built-in Function Provided by GCC:\u000A* int __builtin_popcount(int number)\u000A* original description: \"This function is used to count the number of set bits in an unsigned integer. \"\u000A* \u000A* Adjustment: We don't hand over an integer, we handle a register directly within the function and count the \"1\" within this register.\u000A* return: count of \"!=0\" within this register\u000A*/\u000Atemplate<typename T, int B>\u000AType popcount_builtin(fpvec<T,B>& mask) {\u000A\tType count = 0;\u000A\t#pragma unroll\t\t\t\t\t\t\t\t\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\tif (mask.elements[i] != 0) {\u000A\t\t\tcount++;\u000A\t\t}\u000A\t}\u000A\treturn count;\u000A}\u000A\u000A/**\t#25\u000A* adaption of:\u000A* __m512i _mm512_set1_epi32 (int a)\u000A*\u000A* function create a fpvec<T,B> with all values zero; except at position (value-1) => 1\u000A*/\u000Atemplate<typename T, int B>\u000Afpvec<T,B> setX_singleValue(T value) {\u000A\tauto reg = fpvec<T,B>{};\u000A\t#pragma unroll\t\t\t\t\t\t\t\t\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\treg.elements[i] = 0;\u000A\t}\u000A\treg.elements[value-1] = 1;\u000A\treturn reg;\u000A}\u000A\u000A/**\t#25.1\u000A* adaption of:\u000A* __m512i _mm512_set1_epi32 (int a)\u000A*\u000A* create an empty register reg\u000A* add \"1\" to this register at every position contained in buffer (value-1) !\u000A* size_t conflict_count = amount of conflicts contained in buffer\u000A* \u000A*/\u000Atemplate<typename T, int B>\u000Afpvec<T,B> setX_multipleValues(std::array<Type, elements_per_inner_register>& buffer, size_t conflict_count) {\u000A\tauto reg = fpvec<T,B>{};\u000A\tfor(int i=0; i<conflict_count; i++) {\u000A\t\treg.elements[(buffer[i] - 1)] += 1; \u000A\t}\u000A\treturn reg;\u000A}\u000A\u000A/**\t#26\u000A* serial primitive for Intel Intrinsic:\u000A* __m512i _mm512_mask_i32gather_epi32 (__m512i src, __mmask16 k, __m512i vindex, void const* base_addr, int scale)\u000A* original description: \"Gather 32-bit integers from memory using 32-bit indices. 32-bit elements are loaded from addresses starting \u000A* \tat base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged \u000A*\tinto dst using writemask k (elements are copied from src when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.\"\u000A* \u000A* @param src : register of type fpvec<T,B>\u000A* @param mask_k : writemask k (= register of type fpvec<T,B>)\u000A* @param vindex : register of type fpvec<T,B> \u000A* @param data : void const* base_addr\u000A* @param scale : scale should be 1, 2, 4 or 8\u000A*\t\t-> we don't need an additional scale factor in our implementation, since we always count in whole elements of the registers/arrays\t\u000A*/\u000Atemplate<typename T, int B>\u000Afpvec<T,B> mask_i32gather_epi32(fpvec<T,B>& src, fpvec<T,B>& mask_k, fpvec<T,B>& vindex, std::array<Type, HSIZE>& data) {\u000A\tauto reg = fpvec<T,B>{};\u000A\t#pragma unroll\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\tif(mask_k.elements[i] == (Type)1) {\u000A\t\t\tsize_t addr = 0 + vindex.elements[i];\t// * scale * 8;\t\u000A\t\t\t\t\t\t// 0, because hashVec and countVec starting both at index 0\u000A\t\t\t\t\t\t// omit *8 (because we don't need bit conversion)\u000A\t\t\t\t\t\t// omit *scale, because we currently work with Type=uint32_t in all stages\u000A\t\t\t\t\t\t// if we want to use another datatype, we may adjust the scale paramter within\u000A\t\t\t\t\t\t// this function; now scale doesn't have an usage\u000A\t\t\treg.elements[i] = data[addr];\t\t\t\t\t\t\t\t\t\t\t\t\t\u000A\t\t} else {\u000A\t\t\treg.elements[i] = src.elements[i];\u000A\t\t}\u000A\t}\u000A\treturn reg;\u000A}\u000A\u000A/**\t#27\u000A* serial primitive for Intel Intrinsic:\u000A* __m512i _mm512_maskz_add_epi32 (__mmask16 k, __m512i a, __m512i b)\u000A* original description: \"Add packed 32-bit integers in a and b, and store the results in dst using zeromask k \u000A* (elements are zeroed out when the corresponding mask bit is not set).\"\u000A*/\u000Atemplate<typename T, int B>\u000Afpvec<T,B> maskz_add_epi32(fpvec<T,B>& writeMask, fpvec<T,B>& a, fpvec<T,B>& b) {\u000A\tauto reg = fpvec<T,B>{};\u000A\t#pragma unroll\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\tif (writeMask.elements[i] == 1) {\u000A\t\t\treg.elements[i] = a.elements[i] + b.elements[i];\u000A\t\t}\u000A\t}\u000A\treturn reg;\u000A}\u000A\u000A/**\t#28\u000A* serial primitive for Intel Intrinsic:\u000A* void _mm512_mask_i32scatter_epi32 (void* base_addr, __mmask16 k, __m512i vindex, __m512i a, int scale)\u000A* original description: \"Scatter 32-bit integers from a into memory using 32-bit indices. 32-bit elements are stored at \u000A*\t\taddresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale) \u000A*\t\tsubject to mask k (elements are not stored when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.\"\u000A* \u000A* @param datbaseStoragea : void const* base_addr for storage/scatter\u000A* @param mask_k : writemask k (= register of type fpvec<T,B>)\u000A* @param vindex : register of type fpvec<T,B> \u000A* @param data_to_scatter : register of type fpvec<T,B>\u000A* @param scale : scale should be 1, 2, 4 or 8\t\t\u000A*\t\t-> we don't need an additional scale factor in our implementation, since we always count in whole elements of the registers/arrays\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\u000A* @param tmp_HSIZE : global HashSize (=size of hashVec and countVec) to avoid scatter over the vector borders through false offsets\t\t\u000A*\t\t-> we don't need an additional scale factor in our implementation, since we always count in whole elements of the registers/arrays\t\u000A*/\u000Atemplate<typename T, int B>\u000Avoid mask_i32scatter_epi32(std::array<Type, HSIZE>& baseStorage, fpvec<T,B>& mask_k, fpvec<T,B>& vindex, fpvec<T,B>& data_to_scatter) {\u000A\t#pragma unroll\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\tif(mask_k.elements[i] == (Type)1) {\u000A\t\t\tType addr = 0 + vindex.elements[i];\t\u000A\t\t\t\t\t\t// 0, because hashVec and countVec starting both at index 0\u000A\t\t\t\t\t\t// omit *8 (because we don't need bit conversion)\u000A\t\t\t\t\t\t// omit *scale, because we currently work with Type=uint32_t in all stages\u000A\t\t\t\t\t\t// if we want to use another datatype, we may adjust the scale paramter within\u000A\t\t\t\t\t\t// this function; now scale doesn't have an usage\u000A\t\t\t// if (addr >= HSIZE) { addr = HSIZE-addr; }\t\t\t\t\t\t\u000A\t\t\tbaseStorage[addr] = (Type)data_to_scatter.elements[i];\t\t\t\t\t\t\t\t\t\t\t\t\t\u000A\t\t} \u000A\t}\u000A}\u000A\u000A/**\t#29\u000A* serial primitive for Intel Intrinsic:\u000A* __mmask16 _mm512_kandn (__mmask16 a, __mmask16 b)\u000A* original description: \"Compute the bitwise NOT of (16/...)-bit masks a and then AND with b, and store the result in k.\"\u000A*\u000A* Note: registers a and b may only contain elements of the datatype Type (currently uint32_t) with values ONLY 1 or 0 !!\u000A*/\u000Atemplate<typename T, int B>\u000Afpvec<T,B> kAndn(fpvec<T,B>& a, fpvec<T,B>& b) {\u000A\tauto reg = fpvec<T,B>{};\u000A\t#pragma unroll\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\t\treg.elements[i] = ((~(a.elements[i]))&(b.elements[i]));\u000A\t}\u000A\treturn reg;\u000A}\u000A\u000A/**\t#30\u000A* serial primitive for Intel Intrinsic:\u000A* __mmask16 _mm512_kand (__mmask16 a, __mmask16 b)\u000A* original description: \"Compute the bitwise AND of 16-bit masks a and b, and store the result in k.\"\u000A*\u000A* Note: registers a and b may only contain elements of the datatype Type (currently uint32_t) with values ONLY 1 or 0 !!\u000A*/\u000Atemplate<typename T, int B>\u000Afpvec<T,B> kAnd(fpvec<T,B>& a, fpvec<T,B>& b) {\u000A\tauto reg = fpvec<T,B>{};\u000A\t#pragma unroll\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\treg.elements[i] = ((a.elements[i])&(b.elements[i]));\u000A\t}\u000A\treturn reg;\u000A}\u000A\u000A/**\t#31\u000A* serial primitive for Intel Intrinsic:\u000A* __m512i _mm512_maskz_conflict_epi32 (__mmask16 k, __m512i a)\u000A* original description: \"Test each 32-bit element of a for equality with all other elements in a closer to the least significant bit using zeromask k \u000A* \t\t\t(elements are zeroed out when the corresponding mask bit is not set). Each element's comparison forms a zero extended bit vector in dst.\"\u000A* \u000A* customized maskz_conflict_epi32 - function:\u000A* This function check whether an element is already in the vector a. \u000A* Only elements with a lower index are checked. \u000A* As a result, element 0 in the vector never has a conflict. The bits for each element are then set accordingly. \u000A*\u000A* example:\u000A* index :\t\t\t\t\t\t\t  0  1   2  3  4   5  6   7  8  9 10 11  12  13  14 15\u000A* input array (e.g. loaded values):\t104 71 106 82 82 128 75 109 82 94 59 44 115 124 100 94 \u000A* result of conflict_epi32:\t\t\t  0  0   0  0  8   0  0   0 24  0  0  0   0   0   0 512 \u000A* example input[0..15]\u000A* 1st conflict @ input[4] : 0 0 0 1 ..0 == 0 + 0 + 0 + 2^3 = 8\u000A* 2st conflict @ input[8] : 0 0 0 1 1 ..0 = 0 + 0 + 0 + 2^3 + 2^4 = 24\u000A* 3st conflict @ input[15]: 0 0 0 0 0 0 0 0 1 ..0 = 0 + .. + 0 + 2^9 = 512\u000A*\u000A* Difference against conflict_epi32:\tadditional fpvec<T,B>& mask_k : if mask_k[i]==0 --> result[0]=0 ; else do conflict_epi32 algorithm\u000A* \u000A* @param mask_k\t- writing mask mask_k : if mask_k[i]==0 --> result[0]=0 ; else do conflict_epi32 algorithm\u000A* @param a\t\t- register a : the register in which the algorithm search for conflicts\u000A* @param match_32bit\t-\tan array which contain the exponentation results for 2^m at position m of match_32bit\u000A*/\u000Atemplate<typename T, int B>\u000Afpvec<T,B> maskz_conflict_epi32(fpvec<T,B>& mask_k, fpvec<T,B>& a) {\u000A\tauto reg = fpvec<T,B>{};\u000A\tType match_32bit[32] = {\u000A\t\t0x00000001, 0x00000002, 0x00000004, 0x00000008,\t\u000A\t\t0x00000010, 0x00000020, 0x00000040, 0x00000080,\t\t\t\u000A\t\t0x00000100, 0x00000200, 0x00000400, 0x00000800,\t\t\u000A\t \t0x00001000, 0x00002000, 0x00004000, 0x00008000,\t\t\u000A\t \t0x00010000,\t0x00020000, 0x00040000, 0x00080000,\t\t\u000A\t \t0x00100000,\t0x00200000, 0x00400000, 0x00800000,\t\t\u000A\t \t0x01000000,\t0x02000000, 0x04000000, 0x08000000,\t\t\u000A\t \t0x10000000, 0x20000000, 0x40000000, 0x80000000\t\u000A\t};\u000A\t#pragma unroll\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\tType currentElement = a.elements[i];\u000A\t\tType conflict_calculation = 0x00000000;\u000A\t\tconst int upper_limit = i;\u000A\t\t#pragma unroll\u000A\t\tfor (int j=0; j<upper_limit; j++) {\u000A\t\t\tif((mask_k.elements[upper_limit] == 1) && (a.elements[j] == currentElement)) {\u000A\t\t\t\t// calculate exponentiation\u000A\t\t\t\t/*if (j == 0) {\u000A\t\t\t\t\tconflict_calculation += 1;\u000A\t\t\t\t} else {\u000A\t\t\t\t\tuint64_t tmp = 1;\u000A\t\t\t\t\tfor (int k=1; k<=j; k++) {\u000A\t\t\t\t\t\ttmp = tmp * 2;\u000A\t\t\t\t\t}\u000A\t\t\t\t\tconflict_calculation += tmp;\u000A\t\t\t\t}*/\u000A\t\t\t\tconflict_calculation += match_32bit[j]; \u000A\t\t\t}\u000A\t\t}\t\u000A\t\treg.elements[i] = conflict_calculation;\u000A\t}\t\u000A\treturn reg;\u000A}\u000A\u000A/**\t#32\u000A* serial primitive for Intel Intrinsic:\u000A* __m512i _mm512_and_epi32 (__m512i a, __m512i b)\u000A* original description: \"Compute the bitwise AND of packed 32-bit integers in a and b, and store the results in dst.\"\u000A*/\u000Atemplate<typename T, int B>\u000Afpvec<T,B> register_and(fpvec<T,B>& a, fpvec<T,B>& b) {\u000A\tauto reg = fpvec<T,B>{};\u000A\t#pragma unroll\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\treg.elements[i] = (a.elements[i] & b.elements[i]);\u000A\t}\u000A\treturn reg;\u000A}\u000A\u000A/**\t#33\u000A* serial primitive for Intel Intrinsic:\u000A* __mmask16 _mm512_mask_cmp_epi32_mask (__mmask16 k1, __m512i a, __m512i b, _MM_CMPINT_ENUM imm8)\u000A* original description: \"Compare packed signed 32-bit integers in a and b based on the comparison operand specified by imm8,\u000A* \tand store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\"\u000A*\u000A* NOTE: adjust function to handle ONLY the _MM_CMPINT_NLT (Not less than) comparison, due to the fact that this is the only scenario,\u000A*\t\twhich is used in LinearProbing_v5 (SoA_conflict_v1); Thereby an additional parameter for the cmp type isn't necessary anymore.\u000A*/\u000Atemplate<typename T, int B>\u000Afpvec<T,B> mask_cmp_epi32_mask_NLT(fpvec<T,B>& zeroMask, fpvec<T,B>& a, fpvec<T,B>& b) {\u000A\tauto reg = fpvec<T,B>{};\u000A\t#pragma unroll\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\tif ((zeroMask.elements[i] == 1) && (a.elements[i] < b.elements[i])) {\u000A\t\t\treg.elements[i] = 0;\u000A\t\t}\t\u000A\t\telse {\u000A\t\t\treg.elements[i] = 1;\u000A\t\t}\u000A\t}\t\u000A\treturn reg;\u000A}\u000A////////////////////////////////////////////////////////////////////////////////////////\u000A////////////////////////////////////////////////////////////////////////////////////////\u000A#endif // PRIMITIVES_HPP"}, {"path":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/tbb/2021.8.0/include/tbb/tbb.h", "name":"tbb.h", "has_active_debug_locs":false, "absName":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/tbb/2021.8.0/include/tbb/tbb.h", "content":"/*\u000A    Copyright (c) 2005-2021 Intel Corporation\u000A\u000A    Licensed under the Apache License, Version 2.0 (the \"License\");\u000A    you may not use this file except in compliance with the License.\u000A    You may obtain a copy of the License at\u000A\u000A        http://www.apache.org/licenses/LICENSE-2.0\u000A\u000A    Unless required by applicable law or agreed to in writing, software\u000A    distributed under the License is distributed on an \"AS IS\" BASIS,\u000A    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\u000A    See the License for the specific language governing permissions and\u000A    limitations under the License.\u000A*/\u000A\u000A#include \"../oneapi/tbb.h\"\u000A"}]