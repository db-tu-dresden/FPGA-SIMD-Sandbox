var areaJSON={"columns":["", "ALUTs", "FFs", "RAMs", "DSPs", "MLABs", "Details"], "debug_enabled":"true", "type":"module", "total_percent":[70.4562, 37.5944, 35.2743, 50.8318, 30.9201], "total":[675642, 1316606, 5958, 1781, 1298], "name":"Kernel System", "max_resources":[1866240, 3732480, 11721, 5760, 93312], "children":[{"name":"Static Partition", "type":"partition", "children":[{"name":"Board interface", "type":"resource", "data":[594280, 1.18264e+06, 3737, 1779, 0], "details":[{"type":"text", "text":"Platform interface logic."}]}]}, {"name":"Global interconnect", "type":"resource", "data":[19892, 24000, 104, 0, 0], "details":[{"type":"text", "text":"Global interconnect for 4 global loads and 2 global stores. Reduce number of global loads and stores to simplify global interconnect."}, {"type":"brief", "text":"For 4 global loads and 2 global stores."}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Global Memory Interconnect", "link":"file:////glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/lib/oclfpga/aoc_help_pages/hnj1476724450050.html"}]}]}, {"name":"System description ROM", "type":"resource", "data":[2, 71, 2, 0, 0], "details":[{"type":"text", "text":"This read-only memory contains information for the host about the system and about each kernel in the system, including kernel names, arguments, and attributes. The system description ROM ensures that the binary image on the FPGA is compatible with the host program."}, {"type":"brief", "text":"Contains information for the host."}]}, {"name":"kernelV4", "compute_units":1, "type":"function", "total_percent":[7.18316, 4.68471, 2.94421, 18.0445, 0.0347222], "total_kernel_resources":[61467.5, 109892, 2115, 1.5, 1298], "details":[{"type":"text", "text":"Number of compute units: 1"}, {"type":"brief", "text":"1 compute unit."}], "children":[{"name":"Function overhead", "type":"resource", "data":[1476.52, 1476.68, 0, 0, 6], "details":[{"type":"text", "text":"Kernel dispatch logic."}, {"type":"brief", "text":"Kernel dispatch logic."}]}, {"name":"Coalesced Private Variables: \\n - \'h\' (kernel.cpp:288)\\n - \'i\' (kernel.cpp:287)", "type":"resource", "data":[8, 10, 0, 0, 0], "debug":[[{"filename":"kernel.cpp", "line":287}], [{"filename":"kernel.cpp", "line":288}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 5 bits"}, {"type":"brief", "text":"Register,\\n1 reg, 5 width"}]}, {"name":"Coalesced Private Variables: \\n - \'i_cnt\' (kernel.cpp:230)\\n - \'i_cnt_const\' (kernel.cpp:233)\\n - \'chunk_offset\' (kernel.cpp:235)", "type":"resource", "data":[40, 130, 0, 0, 0], "debug":[[{"filename":"kernel.cpp", "line":230}], [{"filename":"kernel.cpp", "line":233}], [{"filename":"kernel.cpp", "line":235}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 65 bits"}, {"type":"brief", "text":"Register,\\n1 reg, 65 width"}]}, {"name":"Private Variable: \\n - \'hash_key\' (kernel.cpp:246)", "type":"resource", "data":[24, 64, 0, 0, 0], "debug":[[{"filename":"kernel.cpp", "line":246}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 32 bits"}, {"type":"brief", "text":"Register,\\n1 reg, 32 width"}]}, {"name":"Private Variable: \\n - \'i\' (kernel.cpp:287)", "type":"resource", "data":[8, 128, 0, 0, 0], "debug":[[{"filename":"kernel.cpp", "line":287}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 64 bits"}, {"type":"brief", "text":"Register,\\n1 reg, 64 width"}]}, {"name":"Private Variable: \\n - \'i_cnt\' (kernel.cpp:230)", "type":"resource", "data":[24, 64, 0, 0, 0], "debug":[[{"filename":"kernel.cpp", "line":230}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 32 bits"}, {"type":"brief", "text":"Register,\\n1 reg, 32 width"}]}, {"name":"Private Variable: \\n - \'p\' (kernel.cpp:244)", "type":"resource", "data":[16, 78, 0, 0, 0], "debug":[[{"filename":"kernel.cpp", "line":244}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 7 bits"}, {"type":"text", "text":"1 register of width 32 bits"}, {"type":"brief", "text":"Register,\\n1 reg, 7 width,\\n1 reg, 32 width"}]}, {"name":"kernel.cpp:159 (hash_map)", "type":"resource", "data":[0, 0, 1024, 0, 0], "debug":[[{"filename":"kernel.cpp", "line":159}]], "details":[{"type":"table", "Private memory":"Stall-free", "Requested size":"3328 bytes", "Implemented size":"4096 bytes", "Memory Usage":"1024 RAMs", "Number of banks":"1", "Bank width":"16384 bits", "Bank depth":"2 words", "Number of replicates":"1", "Number of private copies":"1", "Additional information":[{"type":"text", "text":"Shallow memory implemented in RAMs instead of MLABs because MLABs cannot be configured in true dual-port mode."}, {"type":"text", "text":"RAM usage is increased from 512 RAMs to 1024 RAMs because the width of individual RAM blocks in true dual-port mode is limited to 20 bits."}, {"type":"text", "text":"Requested size 3328 bytes, implemented size 4096 bytes, stall-free, 2 reads and 3 writes. "}, {"type":"text", "text":"Reducing accesses to exactly one read and one write for all on-chip memory systems may increase overall system performance."}, {"type":"text", "text":"Private memory implemented in on-chip block RAM."}], "Reference":[{"type":"text", "text":"See %L for more information.", "links":[{"guide":"Best Practices Guide : Local Memory", "link":"file:////glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/lib/oclfpga/aoc_help_pages/chn1469549457114.html"}]}]}, {"type":"brief", "text":"Stall-free,\\n3328B requested,\\n4096B implemented."}]}, {"name":"kernel.cpp:160 (count_map)", "type":"resource", "data":[0, 0, 1024, 0, 0], "debug":[[{"filename":"kernel.cpp", "line":160}]], "details":[{"type":"table", "Private memory":"Stall-free", "Requested size":"3328 bytes", "Implemented size":"4096 bytes", "Memory Usage":"1024 RAMs", "Number of banks":"1", "Bank width":"16384 bits", "Bank depth":"2 words", "Number of replicates":"1", "Number of private copies":"1", "Additional information":[{"type":"text", "text":"Shallow memory implemented in RAMs instead of MLABs because MLABs cannot be configured in true dual-port mode."}, {"type":"text", "text":"RAM usage is increased from 512 RAMs to 1024 RAMs because the width of individual RAM blocks in true dual-port mode is limited to 20 bits."}, {"type":"text", "text":"Requested size 3328 bytes, implemented size 4096 bytes, stall-free, 2 reads and 3 writes. "}, {"type":"text", "text":"Reducing accesses to exactly one read and one write for all on-chip memory systems may increase overall system performance."}, {"type":"text", "text":"Private memory implemented in on-chip block RAM."}], "Reference":[{"type":"text", "text":"See %L for more information.", "links":[{"guide":"Best Practices Guide : Local Memory", "link":"file:////glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/lib/oclfpga/aoc_help_pages/chn1469549457114.html"}]}]}, {"type":"brief", "text":"Stall-free,\\n3328B requested,\\n4096B implemented."}]}, {"name":"kernelV4.B0", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[3, 135, 0, 0, 0], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[3, 69, 0, 0, 0]}, {"name":"handler.hpp:1100 > kernel.cpp:230", "type":"resource", "data":[0, 66, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1100}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":230}]]}]}, {"name":"Feedback", "type":"resource", "data":[7, 2, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"handler.hpp:1100 > kernel.cpp:139", "type":"resource", "data":[7, 2, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1100}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":139}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[20, 16, 0, 0, 2], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"handler.hpp:1100 > kernel.cpp:165", "type":"resource", "data":[51, 36, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1100}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":165}]], "children":[{"name":"Store", "type":"resource", "count":2, "data":[51, 36, 0, 0, 0], "details":[{"type":"text", "text":"Store uses a Pipelined never-stall LSU"}, {"type":"brief", "text":"Pipelined never-stall LSU"}, {"type":"text", "text":"Stall-free write to memory declared on %L.", "links":[{"filename":"kernel.cpp", "line":"159"}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}], "replace_name":"true"}, {"name":"handler.hpp:1100 > kernel.cpp:166", "type":"resource", "data":[51, 36, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1100}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":166}]], "children":[{"name":"Store", "type":"resource", "count":2, "data":[51, 36, 0, 0, 0], "details":[{"type":"text", "text":"Store uses a Pipelined never-stall LSU"}, {"type":"brief", "text":"Pipelined never-stall LSU"}, {"type":"text", "text":"Stall-free write to memory declared on %L.", "links":[{"filename":"kernel.cpp", "line":"160"}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}], "replace_name":"true"}, {"name":"handler.hpp:1100 > kernel.cpp:193", "type":"resource", "data":[17, 12, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1100}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":193}]], "children":[{"name":"Store", "type":"resource", "count":1, "data":[17, 12, 0, 0, 0], "details":[{"type":"text", "text":"Store uses a Pipelined never-stall LSU"}, {"type":"brief", "text":"Pipelined never-stall LSU"}, {"type":"text", "text":"Stall-free write to memory declared on %L.", "links":[{"filename":"kernel.cpp", "line":"159"}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}], "replace_name":"true"}, {"name":"handler.hpp:1100 > kernel.cpp:194", "type":"resource", "data":[17, 12, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1100}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":194}]], "children":[{"name":"Store", "type":"resource", "count":1, "data":[17, 12, 0, 0, 0], "details":[{"type":"text", "text":"Store uses a Pipelined never-stall LSU"}, {"type":"brief", "text":"Pipelined never-stall LSU"}, {"type":"text", "text":"Stall-free write to memory declared on %L.", "links":[{"filename":"kernel.cpp", "line":"160"}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}], "replace_name":"true"}, {"name":"handler.hpp:1100 > kernel.cpp:230", "type":"resource", "data":[152, 65, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1100}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":230}]], "children":[{"name":"64-bit Integer Compare", "type":"resource", "count":2, "data":[88, 1, 0, 0, 0]}, {"name":"64-bit Select", "type":"resource", "count":1, "data":[64, 64, 0, 0, 0]}], "replace_name":"true"}]}]}, {"name":"kernelV4.B2", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[93, 225, 3, 0, 0], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[93, 225, 3, 0, 0]}]}, {"name":"Feedback", "type":"resource", "data":[137, 89, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"handler.hpp:1100 > kernel.cpp:230", "type":"resource", "data":[137, 89, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1100}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":230}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[1227, 2383, 0, 0, 119], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"handler.hpp:1100 > kernel.cpp:230", "type":"resource", "data":[134, 66, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1100}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":230}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}, {"name":"65-bit Integer Compare", "type":"resource", "count":1, "data":[68, 1, 0, 0, 0]}, {"name":"65-bit Select", "type":"resource", "count":1, "data":[65, 65, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1100 > kernel.cpp:238 > \\nprimitives.hpp:547", "type":"resource", "data":[9860, 15044, 64, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1100}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":238}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":547}]], "children":[{"name":"Load", "type":"resource", "count":4, "data":[9860, 15044, 64, 0, 0], "details":[{"type":"brief", "text":"Burst-coalesced non-aligned LSU"}, {"type":"text", "text":"Load uses a Burst-coalesced non-aligned LSU.  Use Dynamic Profiler to determine performance impact of this LSU."}]}], "replace_name":"true"}]}]}, {"name":"kernelV4.B3", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[7, 39, 0, 0, 0], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[7, 39, 0, 0, 0]}]}, {"name":"Cluster logic", "type":"resource", "data":[10, 8, 0, 0, 1], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"No Source Line", "type":"resource", "data":[17, 33, 0, 0, 0], "debug":[[{"filename":"", "line":0}]], "children":[{"name":"llvm.fpga.wg.limiter.exit", "type":"resource", "count":1, "data":[17, 33, 0, 0, 0]}]}]}]}, {"name":"kernelV4.B4", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[3428, 19564, 0, 0, 262], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[3428, 19564, 0, 0, 262]}]}, {"name":"Feedback", "type":"resource", "data":[2273, 4237, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[2120, 4096, 0, 0, 0]}, {"name":"handler.hpp:1100 > kernel.cpp:230", "type":"resource", "data":[65, 75, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1100}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":230}]]}, {"name":"handler.hpp:1100 > kernel.cpp:238 > \\nprimitives.hpp:547", "type":"resource", "data":[40, 64, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1100}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":238}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":547}]]}, {"name":"handler.hpp:1100 > kernel.cpp:244", "type":"resource", "data":[48, 2, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1100}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":244}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[2163, 4303, 0, 0, 215], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"No Source Line", "type":"resource", "data":[1413, 261, 0, 0, 0], "debug":[[{"filename":"", "line":0}]], "children":[{"name":"llvm.fpga.case", "type":"resource", "count":9, "data":[1408, 256, 0, 0, 0]}, {"name":"llvm.fpga.fanout", "type":"resource", "count":5, "data":[5, 5, 0, 0, 0]}]}, {"name":"handler.hpp:1100 > kernel.cpp:230", "type":"resource", "data":[1, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1100}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":230}]], "children":[{"name":"1-bit Or", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1100 > kernel.cpp:244", "type":"resource", "data":[1, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1100}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":244}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1100 > kernel.cpp:246 > \\nhelper_kernel.cpp:12", "type":"resource", "data":[187, 81, 0, 1.5, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1100}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":246}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/../helper/helper_kernel.cpp", "line":12}]], "children":[{"name":"32-bit Integer Multiply", "type":"resource", "count":1, "data":[119, 81, 0, 1.5, 0]}, {"name":"64-bit Integer Add", "type":"resource", "count":4, "data":[68, 0, 0, 0, 0]}], "replace_name":"true"}]}]}, {"name":"kernelV4.B5", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[1403, 12472, 0, 0, 137], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[1403, 12472, 0, 0, 137]}]}, {"name":"Feedback", "type":"resource", "data":[240, 511, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[102, 329, 0, 0, 0]}, {"name":"handler.hpp:1100 > kernel.cpp:230", "type":"resource", "data":[76, 173, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1100}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":230}]]}, {"name":"handler.hpp:1100 > kernel.cpp:244", "type":"resource", "data":[12, 5, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1100}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":244}]]}, {"name":"handler.hpp:1100 > kernel.cpp:246", "type":"resource", "data":[32, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1100}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":246}]]}, {"name":"handler.hpp:1100 > kernel.cpp:264", "type":"resource", "data":[9, 2, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1100}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":264}]]}, {"name":"handler.hpp:1100 > kernel.cpp:266", "type":"resource", "data":[9, 2, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1100}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":266}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[1090, 2158, 0, 0, 108], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"No Source Line", "type":"resource", "data":[234, 13, 0, 0, 0], "debug":[[{"filename":"", "line":0}]], "children":[{"name":"1-bit And", "type":"resource", "count":66, "data":[66, 10, 0, 0, 0]}, {"name":"1-bit Or", "type":"resource", "count":5, "data":[5, 0, 0, 0, 0]}, {"name":"32-bit Integer Compare", "type":"resource", "count":64, "data":[161, 1, 0, 0, 0]}, {"name":"llvm.fpga.fanout", "type":"resource", "count":2, "data":[2, 2, 0, 0, 0]}]}, {"name":"handler.hpp:1100 > kernel.cpp:230", "type":"resource", "data":[1, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1100}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":230}]], "children":[{"name":"1-bit Or", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1100 > kernel.cpp:246", "type":"resource", "data":[21.3333, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1100}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":246}]], "children":[{"name":"32-bit Select", "type":"resource", "count":2, "data":[21.3333, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1100 > kernel.cpp:251 > \\nprimitives.hpp:413", "type":"resource", "data":[714, 62, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1100}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":251}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":413}]], "children":[{"name":"1-bit Select", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}, {"name":"32-bit Integer Compare", "type":"resource", "count":64, "data":[704, 54, 0, 0, 0]}, {"name":"Load", "type":"resource", "count":1, "data":[9, 8, 0, 0, 0], "details":[{"type":"text", "text":"Load uses a Pipelined never-stall LSU"}, {"type":"brief", "text":"Pipelined never-stall LSU"}, {"type":"text", "text":"Stall-free read from memory declared on %L.", "links":[{"filename":"kernel.cpp", "line":"159"}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}], "replace_name":"true"}, {"name":"handler.hpp:1100 > kernel.cpp:254 > \\nprimitives.hpp:273", "type":"resource", "data":[62, 2, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1100}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":254}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":273}]], "children":[{"name":"1-bit Select", "type":"resource", "count":62, "data":[62, 2, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1100 > kernel.cpp:255", "type":"resource", "data":[2051, 1, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1100}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":255}]], "children":[{"name":"1-bit Or", "type":"resource", "count":2, "data":[2, 1, 0, 0, 0]}, {"name":"1-bit Select", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}, {"name":"2048-bit Select", "type":"resource", "count":16, "data":[2048, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1100 > kernel.cpp:255 > \\nprimitives.hpp:224", "type":"resource", "data":[64, 64, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1100}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":255}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":224}]], "children":[{"name":"1-bit Select", "type":"resource", "count":64, "data":[64, 64, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1100 > kernel.cpp:259 > \\nprimitives.hpp:413", "type":"resource", "data":[705, 22, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1100}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":259}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":413}]], "children":[{"name":"1-bit Select", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}, {"name":"32-bit Integer Compare", "type":"resource", "count":64, "data":[704, 22, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1100 > kernel.cpp:261 > \\nprimitives.hpp:273", "type":"resource", "data":[64.5, 2, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1100}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":261}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":273}]], "children":[{"name":"1-bit Or", "type":"resource", "count":1, "data":[0.5, 0, 0, 0, 0]}, {"name":"1-bit Select", "type":"resource", "count":64, "data":[64, 2, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1100 > kernel.cpp:262 > \\nprimitives.hpp:452", "type":"resource", "data":[390, 13, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1100}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":262}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":452}]], "children":[{"name":"1-bit Select", "type":"resource", "count":61, "data":[61, 2, 0, 0, 0]}, {"name":"32-bit Select", "type":"resource", "count":63, "data":[329, 11, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1100 > kernel.cpp:264", "type":"resource", "data":[36, 24, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1100}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":264}]], "children":[{"name":"1-bit Or", "type":"resource", "count":2, "data":[2, 0, 0, 0, 0]}, {"name":"Store", "type":"resource", "count":1, "data":[34, 24, 0, 0, 0], "details":[{"type":"text", "text":"Store uses a Pipelined never-stall LSU"}, {"type":"brief", "text":"Pipelined never-stall LSU"}, {"type":"text", "text":"Stall-free write to memory declared on %L.", "links":[{"filename":"kernel.cpp", "line":"159"}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}], "replace_name":"true"}, {"name":"handler.hpp:1100 > kernel.cpp:264 > \\nprimitives.hpp:478", "type":"resource", "data":[2048, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1100}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":264}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":478}]], "children":[{"name":"32-bit Select", "type":"resource", "count":64, "data":[2048, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1100 > kernel.cpp:266", "type":"resource", "data":[34, 24, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1100}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":266}]], "children":[{"name":"Store", "type":"resource", "count":1, "data":[34, 24, 0, 0, 0], "details":[{"type":"text", "text":"Store uses a Pipelined never-stall LSU"}, {"type":"brief", "text":"Pipelined never-stall LSU"}, {"type":"text", "text":"Stall-free write to memory declared on %L.", "links":[{"filename":"kernel.cpp", "line":"160"}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}], "replace_name":"true"}, {"name":"handler.hpp:1100 > kernel.cpp:266 > \\nprimitives.hpp:481", "type":"resource", "data":[2122, 2056, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1100}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":266}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":481}]], "children":[{"name":"1-bit Select", "type":"resource", "count":65, "data":[65, 0, 0, 0, 0]}, {"name":"32-bit Select", "type":"resource", "count":64, "data":[2048, 2048, 0, 0, 0]}, {"name":"Load", "type":"resource", "count":1, "data":[9, 8, 0, 0, 0], "details":[{"type":"text", "text":"Load uses a Pipelined never-stall LSU"}, {"type":"brief", "text":"Pipelined never-stall LSU"}, {"type":"text", "text":"Stall-free read from memory declared on %L.", "links":[{"filename":"kernel.cpp", "line":"160"}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}], "replace_name":"true"}, {"name":"handler.hpp:1100 > kernel.cpp:270", "type":"resource", "data":[21.3333, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1100}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":270}]], "children":[{"name":"32-bit Select", "type":"resource", "count":2, "data":[21.3333, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1100 > kernel.cpp:271", "type":"resource", "data":[56.8333, 1, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1100}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":271}]], "children":[{"name":"1-bit Or", "type":"resource", "count":1, "data":[0.5, 0, 0, 0, 0]}, {"name":"32-bit Integer Compare", "type":"resource", "count":1, "data":[35, 1, 0, 0, 0]}, {"name":"32-bit Select", "type":"resource", "count":2, "data":[21.3333, 0, 0, 0, 0]}], "replace_name":"true"}]}]}, {"name":"kernelV4.B7", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[22, 74, 0, 0, 0], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[22, 74, 0, 0, 0]}]}, {"name":"Feedback", "type":"resource", "data":[85, 9, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"handler.hpp:1100 > kernel.cpp:287", "type":"resource", "data":[85, 9, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1100}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":287}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[2126, 4234, 0, 0, 212], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"handler.hpp:1100 > kernel.cpp:287", "type":"resource", "data":[3, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1100}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":287}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}, {"name":"5-bit Integer Compare", "type":"resource", "count":1, "data":[2, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1100 > kernel.cpp:289 > \\nprimitives.hpp:502", "type":"resource", "data":[12501, 19772, 0, 0, 118], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1100}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":289}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":502}]], "children":[{"name":"Load", "type":"resource", "count":1, "data":[1034, 2057, 0, 0, 0], "details":[{"type":"text", "text":"Load uses a Pipelined never-stall LSU"}, {"type":"brief", "text":"Pipelined never-stall LSU"}, {"type":"text", "text":"Stall-free read from memory declared on %L.", "links":[{"filename":"kernel.cpp", "line":"159"}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}, {"name":"Store", "type":"resource", "count":1, "data":[11467, 17715, 0, 0, 118], "details":[{"type":"brief", "text":"Burst-coalesced non-aligned LSU"}, {"type":"text", "text":"Store uses a Burst-coalesced non-aligned LSU.  Use Dynamic Profiler to determine performance impact of this LSU."}]}], "replace_name":"true"}, {"name":"handler.hpp:1100 > kernel.cpp:290 > \\nprimitives.hpp:502", "type":"resource", "data":[12502, 19772, 0, 0, 118], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1100}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":290}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":502}]], "children":[{"name":"Load", "type":"resource", "count":1, "data":[1034, 2057, 0, 0, 0], "details":[{"type":"text", "text":"Load uses a Pipelined never-stall LSU"}, {"type":"brief", "text":"Pipelined never-stall LSU"}, {"type":"text", "text":"Stall-free read from memory declared on %L.", "links":[{"filename":"kernel.cpp", "line":"160"}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}, {"name":"Store", "type":"resource", "count":1, "data":[11468, 17715, 0, 0, 118], "details":[{"type":"brief", "text":"Burst-coalesced non-aligned LSU"}, {"type":"text", "text":"Store uses a Burst-coalesced non-aligned LSU.  Use Dynamic Profiler to determine performance impact of this LSU."}]}], "replace_name":"true"}]}]}, {"name":"kernelV4.B8", "type":"basicblock", "children":[{"name":"Feedback", "type":"resource", "data":[5, 8, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"handler.hpp:1104", "type":"resource", "data":[5, 8, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1104}]]}]}]}]}]};
var area_srcJSON={"children":[{"children":[{"data":[594280,1182640,3737,1779,0],"details":[{"text":"Platform interface logic.","type":"text"}],"name":"Board interface","type":"resource"}],"name":"Static Partition","type":"partition"},{"data":[19892,24000,104,0,0],"details":[{"text":"Global interconnect for 4 global loads and 2 global stores. Reduce number of global loads and stores to simplify global interconnect.","type":"text"},{"text":"For 4 global loads and 2 global stores.","type":"brief"},{"links":[{"guide":"Best Practices Guide : Global Memory Interconnect","link":"file:////glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/lib/oclfpga/aoc_help_pages/hnj1476724450050.html"}],"text":"See %L for more information","type":"text"}],"name":"Global interconnect","type":"resource"},{"data":[2,71,2,0,0],"details":[{"text":"This read-only memory contains information for the host about the system and about each kernel in the system, including kernel names, arguments, and attributes. The system description ROM ensures that the binary image on the FPGA is compatible with the host program.","type":"text"},{"text":"Contains information for the host.","type":"brief"}],"name":"System description ROM","type":"resource"},{"children":[{"data":[9383,17958,0,0,657],"details":[{"text":"Feedback+Cluster logic","type":"brief"}],"name":"Data control overhead","type":"resource"},{"data":[1476.52,1476.68,0,0,6],"details":[{"text":"Kernel dispatch logic.","type":"text"},{"text":"Kernel dispatch logic.","type":"brief"}],"name":"Function overhead","type":"resource"},{"data":[8,10,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"1 register of width 5 bits","type":"text"},{"text":"Register,\\n1 reg, 5 width","type":"brief"}],"name":"Coalesced Private Variables: \\n - \'h\' (kernel.cpp:288)\\n - \'i\' (kernel.cpp:287)","type":"resource"},{"data":[40,130,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"1 register of width 65 bits","type":"text"},{"text":"Register,\\n1 reg, 65 width","type":"brief"}],"name":"Coalesced Private Variables: \\n - \'i_cnt\' (kernel.cpp:230)\\n - \'i_cnt_const\' (kernel.cpp:233)\\n - \'chunk_offset\' (kernel.cpp:235)","type":"resource"},{"data":[24,64,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"1 register of width 32 bits","type":"text"},{"text":"Register,\\n1 reg, 32 width","type":"brief"}],"name":"Private Variable: \\n - \'hash_key\' (kernel.cpp:246)","type":"resource"},{"data":[8,128,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"1 register of width 64 bits","type":"text"},{"text":"Register,\\n1 reg, 64 width","type":"brief"}],"name":"Private Variable: \\n - \'i\' (kernel.cpp:287)","type":"resource"},{"data":[24,64,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"1 register of width 32 bits","type":"text"},{"text":"Register,\\n1 reg, 32 width","type":"brief"}],"name":"Private Variable: \\n - \'i_cnt\' (kernel.cpp:230)","type":"resource"},{"data":[16,78,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"1 register of width 7 bits","type":"text"},{"text":"1 register of width 32 bits","type":"text"},{"text":"Register,\\n1 reg, 7 width,\\n1 reg, 32 width","type":"brief"}],"name":"Private Variable: \\n - \'p\' (kernel.cpp:244)","type":"resource"},{"data":[0,0,1024,0,0],"details":[{"Additional information":[{"text":"Shallow memory implemented in RAMs instead of MLABs because MLABs cannot be configured in true dual-port mode.","type":"text"},{"text":"RAM usage is increased from 512 RAMs to 1024 RAMs because the width of individual RAM blocks in true dual-port mode is limited to 20 bits.","type":"text"},{"text":"Requested size 3328 bytes, implemented size 4096 bytes, stall-free, 2 reads and 3 writes. ","type":"text"},{"text":"Reducing accesses to exactly one read and one write for all on-chip memory systems may increase overall system performance.","type":"text"},{"text":"Private memory implemented in on-chip block RAM.","type":"text"}],"Bank depth":"2 words","Bank width":"16384 bits","Implemented size":"4096 bytes","Memory Usage":"1024 RAMs","Number of banks":"1","Number of private copies":"1","Number of replicates":"1","Private memory":"Stall-free","Reference":[{"links":[{"guide":"Best Practices Guide : Local Memory","link":"file:////glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/lib/oclfpga/aoc_help_pages/chn1469549457114.html"}],"text":"See %L for more information.","type":"text"}],"Requested size":"3328 bytes","type":"table"},{"text":"Stall-free,\\n3328B requested,\\n4096B implemented.","type":"brief"}],"name":"kernel.cpp:159 (hash_map)","type":"resource"},{"data":[0,0,1024,0,0],"details":[{"Additional information":[{"text":"Shallow memory implemented in RAMs instead of MLABs because MLABs cannot be configured in true dual-port mode.","type":"text"},{"text":"RAM usage is increased from 512 RAMs to 1024 RAMs because the width of individual RAM blocks in true dual-port mode is limited to 20 bits.","type":"text"},{"text":"Requested size 3328 bytes, implemented size 4096 bytes, stall-free, 2 reads and 3 writes. ","type":"text"},{"text":"Reducing accesses to exactly one read and one write for all on-chip memory systems may increase overall system performance.","type":"text"},{"text":"Private memory implemented in on-chip block RAM.","type":"text"}],"Bank depth":"2 words","Bank width":"16384 bits","Implemented size":"4096 bytes","Memory Usage":"1024 RAMs","Number of banks":"1","Number of private copies":"1","Number of replicates":"1","Private memory":"Stall-free","Reference":[{"links":[{"guide":"Best Practices Guide : Local Memory","link":"file:////glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/lib/oclfpga/aoc_help_pages/chn1469549457114.html"}],"text":"See %L for more information.","type":"text"}],"Requested size":"3328 bytes","type":"table"},{"text":"Stall-free,\\n3328B requested,\\n4096B implemented.","type":"brief"}],"name":"kernel.cpp:160 (count_map)","type":"resource"},{"children":[{"count":6,"data":[4956,32443,3,0,399],"debug":[[{"filename":"","line":0}]],"name":"State","type":"resource"},{"count":1,"data":[17,33,0,0,0],"debug":[[{"filename":"","line":0}]],"name":"llvm.fpga.wg.limiter.exit","type":"resource"},{"count":9,"data":[1408,256,0,0,0],"debug":[[{"filename":"","line":0}]],"name":"llvm.fpga.case","type":"resource"},{"count":7,"data":[7,7,0,0,0],"debug":[[{"filename":"","line":0}]],"name":"llvm.fpga.fanout","type":"resource"},{"count":66,"data":[66,10,0,0,0],"debug":[[{"filename":"","line":0}]],"name":"1-bit And","type":"resource"},{"count":5,"data":[5,0,0,0,0],"debug":[[{"filename":"","line":0}]],"name":"1-bit Or","type":"resource"},{"count":64,"data":[161,1,0,0,0],"debug":[[{"filename":"","line":0}]],"name":"32-bit Integer Compare","type":"resource"}],"data":[6620,32750,3,0,399],"name":"No Source Line","type":"resource"},{"children":[{"children":[{"count":"1","data":[0,66,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1100"}]],"name":"State","type":"resource"},{"count":2,"data":[88,1,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1100"}]],"name":"64-bit Integer Compare","type":"resource"},{"count":1,"data":[64,64,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1100"}]],"name":"64-bit Select","type":"resource"},{"count":1,"data":[1,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1100"}]],"name":"1-bit And","type":"resource"},{"count":1,"data":[68,1,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1100"}]],"name":"65-bit Integer Compare","type":"resource"},{"count":1,"data":[65,65,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1100"}]],"name":"65-bit Select","type":"resource"},{"count":2,"data":[2,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1100"}]],"name":"1-bit Or","type":"resource"}],"data":[288,197,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1100},{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp","line":230}]],"name":"handler.hpp:1100 > kernel.cpp:230","replace_name":true,"type":"resource"},{"children":[{"count":2,"data":[51,36,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1100"}]],"name":"Store","type":"resource"}],"data":[51,36,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1100},{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp","line":165}]],"name":"handler.hpp:1100 > kernel.cpp:165","replace_name":true,"type":"resource"},{"children":[{"count":2,"data":[51,36,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1100"}]],"name":"Store","type":"resource"}],"data":[51,36,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1100},{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp","line":166}]],"name":"handler.hpp:1100 > kernel.cpp:166","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[17,12,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1100"}]],"name":"Store","type":"resource"}],"data":[17,12,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1100},{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp","line":193}]],"name":"handler.hpp:1100 > kernel.cpp:193","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[17,12,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1100"}]],"name":"Store","type":"resource"}],"data":[17,12,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1100},{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp","line":194}]],"name":"handler.hpp:1100 > kernel.cpp:194","replace_name":true,"type":"resource"},{"children":[{"count":4,"data":[9860,15044,64,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1100"}]],"name":"Load","type":"resource"}],"data":[9860,15044,64,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1100},{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp","line":238},{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp","line":547}]],"name":"handler.hpp:1100 > kernel.cpp:238 > \\nprimitives.hpp:547","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[1,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1100"}]],"name":"1-bit And","type":"resource"}],"data":[1,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1100},{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp","line":244}]],"name":"handler.hpp:1100 > kernel.cpp:244","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[119,81,0,1.5,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1100"}]],"name":"32-bit Integer Multiply","type":"resource"},{"count":4,"data":[68,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1100"}]],"name":"64-bit Integer Add","type":"resource"}],"data":[187,81,0,1.5,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1100},{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp","line":246},{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/../helper/helper_kernel.cpp","line":12}]],"name":"handler.hpp:1100 > kernel.cpp:246 > \\nhelper_kernel.cpp:12","replace_name":true,"type":"resource"},{"children":[{"count":2,"data":[21.3333,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1100"}]],"name":"32-bit Select","type":"resource"}],"data":[21.3333,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1100},{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp","line":246}]],"name":"handler.hpp:1100 > kernel.cpp:246","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[1,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1100"}]],"name":"1-bit Select","type":"resource"},{"count":64,"data":[704,54,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1100"}]],"name":"32-bit Integer Compare","type":"resource"},{"count":1,"data":[9,8,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1100"}]],"name":"Load","type":"resource"}],"data":[714,62,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1100},{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp","line":251},{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp","line":413}]],"name":"handler.hpp:1100 > kernel.cpp:251 > \\nprimitives.hpp:413","replace_name":true,"type":"resource"},{"children":[{"count":62,"data":[62,2,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1100"}]],"name":"1-bit Select","type":"resource"}],"data":[62,2,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1100},{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp","line":254},{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp","line":273}]],"name":"handler.hpp:1100 > kernel.cpp:254 > \\nprimitives.hpp:273","replace_name":true,"type":"resource"},{"children":[{"count":2,"data":[2,1,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1100"}]],"name":"1-bit Or","type":"resource"},{"count":1,"data":[1,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1100"}]],"name":"1-bit Select","type":"resource"},{"count":16,"data":[2048,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1100"}]],"name":"2048-bit Select","type":"resource"}],"data":[2051,1,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1100},{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp","line":255}]],"name":"handler.hpp:1100 > kernel.cpp:255","replace_name":true,"type":"resource"},{"children":[{"count":64,"data":[64,64,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1100"}]],"name":"1-bit Select","type":"resource"}],"data":[64,64,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1100},{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp","line":255},{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp","line":224}]],"name":"handler.hpp:1100 > kernel.cpp:255 > \\nprimitives.hpp:224","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[1,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1100"}]],"name":"1-bit Select","type":"resource"},{"count":64,"data":[704,22,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1100"}]],"name":"32-bit Integer Compare","type":"resource"}],"data":[705,22,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1100},{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp","line":259},{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp","line":413}]],"name":"handler.hpp:1100 > kernel.cpp:259 > \\nprimitives.hpp:413","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[0.5,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1100"}]],"name":"1-bit Or","type":"resource"},{"count":64,"data":[64,2,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1100"}]],"name":"1-bit Select","type":"resource"}],"data":[64.5,2,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1100},{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp","line":261},{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp","line":273}]],"name":"handler.hpp:1100 > kernel.cpp:261 > \\nprimitives.hpp:273","replace_name":true,"type":"resource"},{"children":[{"count":61,"data":[61,2,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1100"}]],"name":"1-bit Select","type":"resource"},{"count":63,"data":[329,11,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1100"}]],"name":"32-bit Select","type":"resource"}],"data":[390,13,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1100},{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp","line":262},{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp","line":452}]],"name":"handler.hpp:1100 > kernel.cpp:262 > \\nprimitives.hpp:452","replace_name":true,"type":"resource"},{"children":[{"count":2,"data":[2,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1100"}]],"name":"1-bit Or","type":"resource"},{"count":1,"data":[34,24,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1100"}]],"name":"Store","type":"resource"}],"data":[36,24,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1100},{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp","line":264}]],"name":"handler.hpp:1100 > kernel.cpp:264","replace_name":true,"type":"resource"},{"children":[{"count":64,"data":[2048,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1100"}]],"name":"32-bit Select","type":"resource"}],"data":[2048,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1100},{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp","line":264},{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp","line":478}]],"name":"handler.hpp:1100 > kernel.cpp:264 > \\nprimitives.hpp:478","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[34,24,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1100"}]],"name":"Store","type":"resource"}],"data":[34,24,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1100},{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp","line":266}]],"name":"handler.hpp:1100 > kernel.cpp:266","replace_name":true,"type":"resource"},{"children":[{"count":65,"data":[65,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1100"}]],"name":"1-bit Select","type":"resource"},{"count":64,"data":[2048,2048,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1100"}]],"name":"32-bit Select","type":"resource"},{"count":1,"data":[9,8,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1100"}]],"name":"Load","type":"resource"}],"data":[2122,2056,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1100},{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp","line":266},{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp","line":481}]],"name":"handler.hpp:1100 > kernel.cpp:266 > \\nprimitives.hpp:481","replace_name":true,"type":"resource"},{"children":[{"count":2,"data":[21.3333,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1100"}]],"name":"32-bit Select","type":"resource"}],"data":[21.3333,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1100},{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp","line":270}]],"name":"handler.hpp:1100 > kernel.cpp:270","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[0.5,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1100"}]],"name":"1-bit Or","type":"resource"},{"count":1,"data":[35,1,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1100"}]],"name":"32-bit Integer Compare","type":"resource"},{"count":2,"data":[21.3333,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1100"}]],"name":"32-bit Select","type":"resource"}],"data":[56.8333,1,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1100},{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp","line":271}]],"name":"handler.hpp:1100 > kernel.cpp:271","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[1,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1100"}]],"name":"1-bit And","type":"resource"},{"count":1,"data":[2,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1100"}]],"name":"5-bit Integer Compare","type":"resource"}],"data":[3,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1100},{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp","line":287}]],"name":"handler.hpp:1100 > kernel.cpp:287","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[1034,2057,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1100"}]],"name":"Load","type":"resource"},{"count":1,"data":[11467,17715,0,0,118],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1100"}]],"name":"Store","type":"resource"}],"data":[12501,19772,0,0,118],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1100},{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp","line":289},{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp","line":502}]],"name":"handler.hpp:1100 > kernel.cpp:289 > \\nprimitives.hpp:502","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[1034,2057,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1100"}]],"name":"Load","type":"resource"},{"count":1,"data":[11468,17715,0,0,118],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1100"}]],"name":"Store","type":"resource"}],"data":[12502,19772,0,0,118],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1100},{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp","line":290},{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp","line":502}]],"name":"handler.hpp:1100 > kernel.cpp:290 > \\nprimitives.hpp:502","replace_name":true,"type":"resource"}],"data":[43867.9999,57233,64,1.5,236],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1100}]],"name":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp:1100","type":"resource"}],"compute_units":1,"data":[61467.5199,109891.68,2115,1.5,1298],"debug":[[{"filename":"kernel.cpp","line":159}]],"details":[{"text":"Number of compute units: 1","type":"text"},{"text":"1 compute unit.","type":"brief"}],"name":"kernelV4","total_kernel_resources":[61467.5,109892,2115,1.5,1298],"total_percent":[7.18316,4.68471,2.94421,18.0445,0.0347222],"type":"function"}],"columns":["","ALUTs","FFs","RAMs","DSPs","MLABs","Details"],"data":[81361.5199,133962.68,2221,1.5,1298],"debug_enabled":"true","max_resources":[1866240,3732480,11721,5760,93312],"name":"Kernel System","total":[675642,1316606,5958,1781,1298],"total_percent":[70.4562,37.5944,35.2743,50.8318,30.9201],"type":"module"};
var mavJSON={"nodes":[{"type":"kernel", "id":2, "name":"kernelV4", "children":[{"type":"bb", "id":3, "name":"kernelV4.B0", "children":[{"type":"inst", "id":12, "name":"Store", "debug":[[{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":165}]], "details":[{"type":"table", "Width":"16384 bits", "Type":"Pipelined never-stall", "Stall-free":"Yes", "Stores to":"hash_map", "Start Cycle":"4", "Latency":"1", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}]}, {"type":"inst", "id":13, "name":"Store", "debug":[[{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":166}]], "details":[{"type":"table", "Width":"16384 bits", "Type":"Pipelined never-stall", "Stall-free":"Yes", "Stores to":"count_map", "Start Cycle":"4", "Latency":"1", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}]}, {"type":"inst", "id":14, "name":"Store", "debug":[[{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":165}]], "details":[{"type":"table", "Width":"16384 bits", "Type":"Pipelined never-stall", "Stall-free":"Yes", "Stores to":"hash_map", "Start Cycle":"4", "Latency":"1", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}]}, {"type":"inst", "id":15, "name":"Store", "debug":[[{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":166}]], "details":[{"type":"table", "Width":"16384 bits", "Type":"Pipelined never-stall", "Stall-free":"Yes", "Stores to":"count_map", "Start Cycle":"4", "Latency":"1", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}]}, {"type":"inst", "id":28, "name":"Begin", "details":[{"type":"table", "Start Cycle":"0", "Latency":"1"}]}, {"type":"inst", "id":29, "name":"End", "details":[{"type":"table", "Start Cycle":"9", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"9"}]}, {"type":"bb", "id":4, "name":"kernelV4.B1", "details":[{"type":"table", "Latency":"0"}]}, {"type":"bb", "id":5, "name":"kernelV4.B2", "children":[{"type":"inst", "id":16, "name":"Load", "debug":[[{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":547}]], "details":[{"type":"table", "Width":"512 bits", "Type":"Burst-coalesced non-aligned", "Stall-free":"No", "Start Cycle":"9", "Latency":"847", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}]}, {"type":"inst", "id":17, "name":"Load", "debug":[[{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":547}]], "details":[{"type":"table", "Width":"512 bits", "Type":"Burst-coalesced non-aligned", "Stall-free":"No", "Start Cycle":"9", "Latency":"847", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}]}, {"type":"inst", "id":18, "name":"Load", "debug":[[{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":547}]], "details":[{"type":"table", "Width":"512 bits", "Type":"Burst-coalesced non-aligned", "Stall-free":"No", "Start Cycle":"9", "Latency":"847", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}]}, {"type":"inst", "id":19, "name":"Load", "debug":[[{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":547}]], "details":[{"type":"table", "Width":"512 bits", "Type":"Burst-coalesced non-aligned", "Stall-free":"No", "Start Cycle":"9", "Latency":"847", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}]}, {"type":"inst", "id":30, "name":"Loop Input", "debug":[[{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":230}]], "details":[{"type":"table", "Start Cycle":"0", "Latency":"1", "Loops To":"6"}]}, {"type":"inst", "id":31, "name":"End", "details":[{"type":"table", "Start Cycle":"861", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"861", "II":"2", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Entry to loop. "}]}, {"type":"bb", "id":6, "name":"kernelV4.B3", "details":[{"type":"table", "Latency":"6", "II":"2", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Exit which branches back to loop. "}]}, {"type":"bb", "id":7, "name":"kernelV4.B4", "details":[{"type":"table", "Latency":"19", "II":"1", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Entry to loop. ", "Loops To":"9"}]}, {"type":"bb", "id":8, "name":"kernelV4.B5", "children":[{"type":"inst", "id":20, "name":"Load", "debug":[[{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":413}]], "details":[{"type":"table", "Width":"2048 bits", "Type":"Pipelined never-stall", "Stall-free":"Yes", "Loads from":"hash_map", "Start Cycle":"5", "Latency":"1", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}]}, {"type":"inst", "id":21, "name":"Store", "debug":[[{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":264}]], "details":[{"type":"table", "Width":"2048 bits", "Type":"Pipelined never-stall", "Stall-free":"Yes", "Stores to":"hash_map", "Start Cycle":"8", "Latency":"1", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}]}, {"type":"inst", "id":22, "name":"Load", "debug":[[{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":481}]], "details":[{"type":"table", "Width":"2048 bits", "Type":"Pipelined never-stall", "Stall-free":"Yes", "Loads from":"count_map", "Start Cycle":"12", "Latency":"1", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}]}, {"type":"inst", "id":23, "name":"Store", "debug":[[{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":266}]], "details":[{"type":"table", "Width":"2048 bits", "Type":"Pipelined never-stall", "Stall-free":"Yes", "Stores to":"count_map", "Start Cycle":"14", "Latency":"1", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}]}, {"type":"inst", "id":32, "name":"Loop Input", "debug":[[{"filename":"", "line":0}]], "details":[{"type":"table", "Start Cycle":"0", "Latency":"1", "Loops To":"33"}]}, {"type":"inst", "id":33, "name":"Loop End", "details":[{"type":"table", "Start Cycle":"19", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"19", "II":"4", "Subloops":"No", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Loop is pipelined with II of 4. See Loops Analysis for more information."}]}, {"type":"bb", "id":9, "name":"kernelV4.B6", "details":[{"type":"table", "Latency":"0", "II":"1", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Exit which branches back to loop. "}]}, {"type":"bb", "id":10, "name":"kernelV4.B7", "children":[{"type":"inst", "id":24, "name":"Load", "debug":[[{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":502}]], "details":[{"type":"table", "Width":"2048 bits", "Type":"Pipelined never-stall", "Stall-free":"Yes", "Loads from":"hash_map", "Start Cycle":"4", "Latency":"1", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}]}, {"type":"inst", "id":25, "name":"Load", "debug":[[{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":502}]], "details":[{"type":"table", "Width":"2048 bits", "Type":"Pipelined never-stall", "Stall-free":"Yes", "Loads from":"count_map", "Start Cycle":"4", "Latency":"1", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}]}, {"type":"inst", "id":26, "name":"Store", "debug":[[{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":502}]], "details":[{"type":"table", "Width":"2048 bits", "Type":"Burst-coalesced non-aligned", "Stall-free":"No", "Start Cycle":"10", "Latency":"2", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}]}, {"type":"inst", "id":27, "name":"Store", "debug":[[{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":502}]], "details":[{"type":"table", "Width":"2048 bits", "Type":"Burst-coalesced non-aligned", "Stall-free":"No", "Start Cycle":"10", "Latency":"2", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}]}, {"type":"inst", "id":34, "name":"Loop Input", "debug":[[{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":287}]], "details":[{"type":"table", "Start Cycle":"0", "Latency":"1", "Loops To":"35"}]}, {"type":"inst", "id":35, "name":"Loop End", "details":[{"type":"table", "Start Cycle":"12", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"12", "II":"1", "Subloops":"No", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":""}]}, {"type":"bb", "id":11, "name":"kernelV4.B8", "details":[{"type":"table", "Latency":"0"}]}, {"type":"csr", "id":36, "name":"Register Map", "debug":[[{"filename":"main.prj/ZTS8kernelV4_csr.hpp", "line":1}]], "children":[{"type":"interface", "id":37, "name":"start", "debug":[[{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":129}]]}, {"type":"interface", "id":38, "name":"done", "debug":[[{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":129}]]}, {"type":"interface", "id":39, "name":"busy", "debug":[[{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":129}]]}, {"type":"interface", "id":40, "name":"arg_arr_d", "debug":[[{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":129}]], "details":[{"type":"table", "Stable":"No", "Width":"64 bits", "Kernel":"ZTS8kernelV4"}]}, {"type":"interface", "id":41, "name":"arg_hashVec_d", "debug":[[{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":129}]], "details":[{"type":"table", "Stable":"No", "Width":"64 bits", "Kernel":"ZTS8kernelV4"}]}, {"type":"interface", "id":42, "name":"arg_countVec_d", "debug":[[{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":129}]], "details":[{"type":"table", "Stable":"No", "Width":"64 bits", "Kernel":"ZTS8kernelV4"}]}, {"type":"interface", "id":43, "name":"arg_iterations", "debug":[[{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":129}]], "details":[{"type":"table", "Stable":"No", "Width":"64 bits", "Kernel":"ZTS8kernelV4"}]}]}, {"type":"memtype", "id":44, "name":"On-chip Memory", "children":[{"type":"memsys", "id":45, "name":"hash_map", "debug":[[{"filename":"kernel.cpp", "line":159}]], "details":[{"type":"table", "Requested size":"3328 bytes", "Implemented size":"4096 bytes", "Number of banks":"1", "Bank width":"16384 bits", "Bank depth":"2 words", "Number of replicates":"1", "Number of private copies":"1", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Local Memory", "link":"file:////glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/lib/oclfpga/aoc_help_pages/chn1469549457114.html"}]}]}]}, {"type":"memsys", "id":51, "name":"count_map", "debug":[[{"filename":"kernel.cpp", "line":160}]], "details":[{"type":"table", "Requested size":"3328 bytes", "Implemented size":"4096 bytes", "Number of banks":"1", "Bank width":"16384 bits", "Bank depth":"2 words", "Number of replicates":"1", "Number of private copies":"1", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Local Memory", "link":"file:////glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/lib/oclfpga/aoc_help_pages/chn1469549457114.html"}]}]}]}]}]}, {"type":"memtype", "id":1, "name":"Global Memory", "children":[{"type":"memsys", "id":57, "name":"device", "details":[{"type":"table", "Number of banks":"4"}]}]}], "links":[{"from":37, "to":28}, {"from":11, "to":38}, {"from":28, "to":39, "reverse":2}, {"from":40, "to":30}, {"from":41, "to":34}, {"from":42, "to":34}, {"from":43, "to":28}, {"from":45, "to":24}, {"from":45, "to":20}, {"from":14, "to":45}, {"from":12, "to":45}, {"from":21, "to":45}, {"from":51, "to":25}, {"from":51, "to":22}, {"from":15, "to":51}, {"from":13, "to":51}, {"from":23, "to":51}, {"from":12, "to":29}, {"from":13, "to":29}, {"from":14, "to":29}, {"from":15, "to":29}, {"from":6, "to":4}, {"from":6, "to":30}, {"from":29, "to":30}, {"from":16, "to":31}, {"from":17, "to":31}, {"from":18, "to":31}, {"from":19, "to":31}, {"from":9, "to":6}, {"from":9, "to":7}, {"from":31, "to":7}, {"from":33, "to":32}, {"from":7, "to":32}, {"from":21, "to":33}, {"from":23, "to":33}, {"from":33, "to":9}, {"from":35, "to":34}, {"from":4, "to":34}, {"from":24, "to":35}, {"from":25, "to":35}, {"from":26, "to":35}, {"from":27, "to":35}, {"from":35, "to":11}, {"from":28, "to":12}, {"from":28, "to":13}, {"from":28, "to":14}, {"from":28, "to":15}, {"from":30, "to":16}, {"from":30, "to":17}, {"from":30, "to":18}, {"from":30, "to":19}, {"from":32, "to":20}, {"from":20, "to":21}, {"from":20, "to":22}, {"from":20, "to":23}, {"from":22, "to":23}, {"from":34, "to":24}, {"from":34, "to":25}, {"from":24, "to":26}, {"from":25, "to":26}, {"from":24, "to":27}, {"from":25, "to":27}, {"from":57, "to":16}, {"from":57, "to":17}, {"from":57, "to":18}, {"from":57, "to":19}, {"from":26, "to":57}, {"from":27, "to":57}]};
var loopsJSON={"columns":["", "Pipelined", "II", "Speculated iterations", "Details"], "children":[{"name":"Kernel: kernelV4", "data":["", "", ""], "debug":[[{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":129}]], "details":[{"type":"brief", "text":"Single work-item execution"}, {"type":"text", "text":"Single work-item execution"}, {"type":"text", "text":"fMAX bottleneck blocks: kernelV4.B5, kernelV4.B7"}, {"type":"text", "text":"Use the %L report to view more details", "links":[{"view":"Fmax II Report"}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Kernels", "link":"file:////glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/lib/oclfpga/aoc_help_pages/ipp1476408832230.html"}]}], "children":[{"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"kernel.cpp", "line":164}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"primitives.hpp", "line":89}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"primitives.hpp", "line":89}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"primitives.hpp", "line":89}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"primitives.hpp", "line":89}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"primitives.hpp", "line":131}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[{"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"primitives.hpp", "line":134}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"primitives.hpp", "line":477}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"primitives.hpp", "line":569}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}, {"name":"kernelV4.B2", "data":["Yes", ">=2", "2"], "debug":[[{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":230}]], "details":[{"type":"text", "text":"Stallable instruction: n/a"}, {"type":"text", "text":"Maximum concurrent iterations: Capacity of loop", "details":[{"type":"text", "text":"Use the %L viewer to estimate capacity", "links":[{"view":"Fmax II Report"}]}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Nested Loops", "link":"file:////glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/lib/oclfpga/aoc_help_pages/rfr1469543500580.html"}]}], "children":[{"name":"kernelV4.B4", "data":["Yes", ">=1", "4"], "debug":[[{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":244}]], "details":[{"type":"text", "text":"Stallable instruction: n/a"}, {"type":"text", "text":"Maximum concurrent iterations: Capacity of loop", "details":[{"type":"text", "text":"Use the %L viewer to estimate capacity", "links":[{"view":"Fmax II Report"}]}]}, {"type":"text", "text":"Average Trip count: 64 (exact)"}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Nested Loops", "link":"file:////glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/lib/oclfpga/aoc_help_pages/rfr1469543500580.html"}]}], "children":[{"name":"kernelV4.B5", "data":["Yes", "4", "2"], "debug":[[{"filename":"Unknown location", "line":0}]], "details":[{"type":"brief", "text":"Memory dependency"}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1100"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":"251"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":"413"}]}, {"type":"text", "text":"To: Store Operation (%L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1100"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":"264"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1100"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":"251"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":"413"}]}, {"type":"text", "text":"To: Load Operation (%L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1100"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":"251"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":"413"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1100"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":"251"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":"413"}]}, {"type":"text", "text":"To: Load Operation (%L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1100"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":"238"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":"547"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1100"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":"251"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":"413"}]}, {"type":"text", "text":"To: Load Operation (%L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1100"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":"238"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":"547"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1100"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":"251"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":"413"}]}, {"type":"text", "text":"To: Load Operation (%L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1100"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":"238"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":"547"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1100"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":"251"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":"413"}]}, {"type":"text", "text":"To: Load Operation (%L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1100"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":"238"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":"547"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1100"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":"266"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":"481"}]}, {"type":"text", "text":"To: Store Operation (%L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1100"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":"266"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1100"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":"266"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":"481"}]}, {"type":"text", "text":"To: Load Operation (%L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1100"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":"251"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":"413"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1100"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":"266"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":"481"}]}, {"type":"text", "text":"To: Load Operation (%L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1100"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":"238"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":"547"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1100"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":"266"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":"481"}]}, {"type":"text", "text":"To: Load Operation (%L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1100"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":"238"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":"547"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1100"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":"266"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":"481"}]}, {"type":"text", "text":"To: Load Operation (%L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1100"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":"238"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":"547"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1100"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":"266"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":"481"}]}, {"type":"text", "text":"To: Load Operation (%L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1100"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":"238"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":"547"}]}]}, {"type":"text", "text":"Most critical loop feedback path during scheduling:", "details":[{"type":"text", "text":"Number of nodes in critical path exceeded what the compiler has captured. Only the top 18 failing nodes are listed.", "details":[{"type":"text", "text":"1.00 clock cycle 32-bit Select Operation (%L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1100"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":"262"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":"452"}]}, {"type":"text", "text":"1.00 clock cycle 1-bit Select Operation (%L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1100"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":"262"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":"452"}]}, {"type":"text", "text":"1.00 clock cycle 32-bit Select Operation (%L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1100"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":"262"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":"452"}]}, {"type":"text", "text":"1.00 clock cycle 32-bit Select Operation (%L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1100"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":"262"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":"452"}]}, {"type":"text", "text":"1.00 clock cycle Load Operation (%L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1100"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":"251"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":"413"}]}, {"type":"text", "text":"1.00 clock cycle 32-bit Integer Compare Operation (%L)", "links":[{"filename":"Unknown location", "line":"0"}]}, {"type":"text", "text":"1.00 clock cycle 32-bit Select Operation (%L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1100"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":"262"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":"452"}]}, {"type":"text", "text":"1.00 clock cycle 1-bit Select Operation (%L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1100"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":"262"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":"452"}]}, {"type":"text", "text":"1.00 clock cycle 32-bit Select Operation (%L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1100"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":"262"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":"452"}]}, {"type":"text", "text":"1.00 clock cycle 32-bit Select Operation (%L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1100"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":"264"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":"478"}]}, {"type":"text", "text":"1.00 clock cycle 32-bit Select Operation (%L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1100"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":"262"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":"452"}]}, {"type":"text", "text":"1.00 clock cycle 32-bit Select Operation (%L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1100"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":"262"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":"452"}]}, {"type":"text", "text":"1.00 clock cycle Store Operation (%L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1100"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":"264"}]}, {"type":"text", "text":"1.00 clock cycle 32-bit Select Operation (%L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1100"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":"262"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":"452"}]}, {"type":"text", "text":"1.00 clock cycle 32-bit Select Operation (%L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1100"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":"262"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":"452"}]}, {"type":"text", "text":"1.00 clock cycle 1-bit Select Operation (%L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1100"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":"262"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":"452"}]}, {"type":"text", "text":"0.82 clock cycles 32-bit Integer Add Operation (%L)", "links":[{"filename":"Unknown location", "line":"0"}]}, {"type":"text", "text":"0.74 clock cycles 32-bit Integer Compare Operation (%L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1100"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":"259"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":"413"}]}]}]}, {"type":"text", "text":"Stallable instruction: None"}, {"type":"text", "text":"Maximum concurrent iterations: Capacity of loop", "details":[{"type":"text", "text":"Use the %L viewer to estimate capacity", "links":[{"view":"Fmax II Report"}]}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Loops in a Single Work-Item Kernel", "link":"file:////glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/lib/oclfpga/aoc_help_pages/wfa1476380079940.html"}]}], "children":[{"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"primitives.hpp", "line":222}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"primitives.hpp", "line":272}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"primitives.hpp", "line":272}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"primitives.hpp", "line":412}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"primitives.hpp", "line":412}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"primitives.hpp", "line":452}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"primitives.hpp", "line":477}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"primitives.hpp", "line":477}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}]}]}]}, {"name":"kernelV4.B7", "data":["Yes", "~1", "4"], "debug":[[{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":287}]], "details":[{"type":"text", "text":"II is an approximation due to the following stallable instructions:", "details":[{"type":"text", "text":"Store Operation (%L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1100"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":"289"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":"502"}]}, {"type":"text", "text":"Store Operation (%L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1100"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":"290"}, {"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/./../primitives/primitives.hpp", "line":"502"}]}]}, {"type":"text", "text":"Maximum concurrent iterations: Capacity of loop", "details":[{"type":"text", "text":"Use the %L viewer to estimate capacity", "links":[{"view":"Fmax II Report"}]}]}, {"type":"text", "text":"Average Trip count: 13 (exact)"}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Loops in a Single Work-Item Kernel", "link":"file:////glob/development-tools/versions/oneapi/2023.0.1/oneapi/compiler/2023.0.0/linux/lib/oclfpga/aoc_help_pages/wfa1476380079940.html"}]}], "children":[{"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"primitives.hpp", "line":501}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"primitives.hpp", "line":501}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}]}]}]};
var loop_attrJSON={"name":"loop_attributes", "id":1249, "nodes":[{"name":"kernelV4", "id":1, "clk":"No", "fmax":"480.00", "type":"kernel", "children":[{"name":"kernelV4.B0", "id":2, "af":"480.00", "br":"0", "ci":"0", "fo":"Disabled", "ii":"1", "ll":"1", "lt":"9.000000", "mi":"n/a", "pl":"Yes", "tc":"0", "tn":"1", "type":"bb"}, {"name":"kernelV4.B2", "id":4, "af":"480.00", "br":"0", "ci":"0", "fo":"Enabled", "ii":"2", "ll":"1", "lt":"861.000000", "mi":"1", "pl":"Yes", "tc":"0", "tn":"1", "details":[{"type":"text", "text":"Hyper-Optimized loop structure: enabled."}], "debug":[[{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":230}]], "type":"loop", "children":[{"name":"kernelV4.B4", "id":6, "af":"480.00", "br":"0", "ci":"0", "fo":"Enabled", "ii":"1", "ll":"2", "lt":"19.000000", "mi":"1", "pl":"Yes", "tc":"0", "tn":"1", "details":[{"type":"text", "text":"Hyper-Optimized loop structure: enabled."}], "debug":[[{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":249}]], "type":"loop", "children":[{"name":"kernelV4.B5", "id":7, "af":"270.00", "br":"1", "ci":"0", "fo":"Enabled", "ii":"4", "ll":"3", "lt":"19.000000", "mi":"1", "pl":"Yes", "tc":"0", "tn":"1", "details":[{"type":"text", "text":"Hyper-Optimized loop structure: enabled."}], "debug":[[{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":249}]], "type":"loop"}]}, {"name":"kernelV4.B6", "id":8, "af":"480.00", "br":"1", "ci":"0", "fo":"Disabled", "ii":"1", "ll":"2", "lt":"0.000000", "mi":"n/a", "pl":"Yes", "tc":"64", "tn":"1", "type":"bb"}]}, {"name":"kernelV4.B3", "id":5, "af":"480.00", "br":"1", "ci":"0", "fo":"Disabled", "ii":"1", "ll":"1", "lt":"6.000000", "mi":"n/a", "pl":"Yes", "tc":"0", "tn":"1", "type":"bb"}, {"name":"kernelV4.B1", "id":3, "af":"480.00", "br":"0", "ci":"0", "fo":"Disabled", "ii":"1", "ll":"1", "lt":"0.000000", "mi":"n/a", "pl":"Yes", "tc":"0", "tn":"1", "type":"bb"}, {"name":"kernelV4.B7", "id":9, "af":"432.00", "br":"1", "ci":"0", "fo":"Enabled", "ii":"1", "ll":"1", "lt":"12.000000", "mi":"1", "pl":"Yes", "tc":"13", "tn":"1", "details":[{"type":"text", "text":"Hyper-Optimized loop structure: enabled."}], "debug":[[{"filename":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "line":287}]], "type":"loop"}, {"name":"kernelV4.B8", "id":10, "af":"480.00", "br":"0", "ci":"0", "fo":"Disabled", "ii":"1", "ll":"1", "lt":"1.000000", "mi":"n/a", "pl":"Yes", "tc":"0", "tn":"1", "type":"bb"}]}]};
var summaryJSON={"performanceSummary":{"name":"Kernel Summary", "columns":["Kernel Name", "Kernel Type", "Autorun", "Workgroup Size", "# Compute Units", "Hyper-Optimized Handshaking"], "children":[{"name":"kernelV4", "data":["Single work-item", "No", [1, 1, 1], 1, "Off"], "details":[{"type":"text", "text":"Kernel type: Single work-item"}, {"type":"text", "text":"Required workgroup size: (1, 1, 1)"}, {"type":"text", "text":"Maximum workgroup size: 1"}, {"type":"text", "text":"Hyper-optimized handshaking disabled due to instruction llvm.fpga.wg.limiter.enter Operation which does not support it."}], "debug":[[{"filename":"", "line":0}]]}]}, "estimatedResources":{"name":"Estimated Resource Usage", "columns":["Kernel Name", "ALUTs ", "FFs  ", "RAMs ", "DSPs ", "MLABs"], "children":[{"name":"kernelV4", "data":[61467.5, 109892, 2115, 1.5, 1298], "debug":[[{"filename":"", "line":0}]]}, {"name":"Global Interconnect", "classes":["summary-highlight", "nohover"], "data":[19892, 24000, 104, 0, 0]}, {"name":"Board Interface", "classes":["summary-highlight", "nohover"], "data":[594280, 1182643, 3737, 1779, 0]}, {"name":"System description ROM", "classes":["summary-highlight", "nohover"], "data":[2, 71, 2, 0, 0]}, {"name":"Total", "classes":["summary-highlight", "nohover"], "data":[675641, 1316605, 5958, 1780, 1298], "data_percent":[36.2034, 35.2743, 50.8318, 30.9201]}, {"name":"Available", "classes":["summary-highlight", "nohover"], "data":[1866240, 3732480, 11721, 5760, 0]}]}, "compileWarnings":{"name":"Compile Warnings", "children":[]}};
var warningsJSON={"nodes":[]};
var fileJSON=[{"path":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/config/global_settings.hpp", "name":"global_settings.hpp", "has_active_debug_locs":false, "absName":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/config/global_settings.hpp", "content":"#ifndef GLOBAL_SETTINGS_HPP_\u000A#define GLOBAL_SETTINGS_HPP_\u000A\u000A#include <stdio.h>\u000A#include <stdlib.h>\u000A#include <stdint.h>\u000A\u000A////////////////////////////////////////////////////////////////////////////////\u000A////////////////////////////////////////////////////////////////////////////////\u000A//// Define global parameters (on host) for data generation\u000A/**\u000A * @param distinctValues determines the generated values between 1 and distinctValues\u000A * @param multiplier\u000A * @param dataSize number of tuples respectively elements in hashVec[] and countVec[]\u000A * @param scale multiplier to determine the value of the HSIZE (note \"1.6\" corresponds to 60% more slots in the hashVec[] than there are distinctValues \u000A * @param HSIZE HashSize (corresponds to size of hashVec[] and countVec[])\u000A * @param Type define datatype which is used within all registers\u000A * @param regSize define register-size (in byte), which defines the amount of data that is load within one clock cycle :: (64=512bit; 128=1024bit; 192=1536bit; 256=2048bit;)\u000A */\u000A    //define distinctValues (uint64_t) 8000\u000A    #define distinctValues (uint64_t) 512\u000A\u000A    // change of multiplier not really necessary, but when: only in steps of 16 => e.g. 16, 32, 64 ...\u000A    // and : multiplier should be equal with value of kValuesPerLSU in kernel.cpp\u000A    #define multiplier (int) 16\u000A    #define dataSize (uint64_t) (multiplier*10240000)               // 10240000*16 = 163840000 --> MOD 16 = 0; MOD 4096 = 0\u000A    #define scale (float) (1.6)\u000A    #define HSIZE (uint64_t) (distinctValues*scale)\u000A\u000A//////// Up to this point the parameters can be adjusted.\u000A////////////////////////////////////////////////////////////////////////////////\u000A\u000A\u000A\u000A\u000A////////////////////////////////////////////////////////////////////////////////\u000A//////// DO NOT CHANGE THE FOLLOWING SETTINGS :\u000A    /**\u000A     * define datatype which is used within all registers\u000A     * NOTE: DON'T CHANGE these parameters!\u000A     */ \u000A    using Type = uint32_t;     \u000A    using TypeSigned = int32_t;\u000A\u000A    /**\u000A    * define register-size (in byte), which defines the amount of data that is load within one clock cycle\u000A    * NOTE: 64=512bit; 128=1024bit; 192=1536bit; 256=2048bit;\u000A    * NOTE: DON'T CHANGE - PLEASE USE ONLY 256 byte !\u000A    * NOTE: \tDue to current data loading approach, regSize must be 256 byte, so that\u000A    *           every register has a overall size of 2048 bit so that it can be loaded in one cycle using the 4 memory controllers\u000A    */\u000A    #define regSize (int) 256               // bytes\u000A    #define inner_regSize (int) 64          // bytes\u000A\u000A    #define elements_per_register (int) (regSize/sizeof(Type))                      // old variable name : \"elementCount\" \u000A    #define elements_per_inner_register (int) (inner_regSize/sizeof(Type))          // old variable name : \"inner_elementCount\" \u000A\u000A\u000A    // define additional variables and datastructures - only for LinearProbingFPGA_variant4()\u000A\t#define m_elements_per_vector (size_t) (elements_per_inner_register) \t\t\t// should be equivalent to (regSize)/sizeof(Type);\t\t\u000A\t#define m_HSIZE_v (size_t) ((HSIZE + m_elements_per_vector - 1) / m_elements_per_vector)\u000A    #define HSIZE_hashMap_v4 (size_t) (m_elements_per_vector * m_HSIZE_v)\u000A\t#define m_HSIZE (size_t) (HSIZE)\u000A\u000A    // only for v4_2048bit\u000A\t#define m_elements_per_vector_v4_2048bit (size_t) (elements_per_register) \t\t\t// should be equivalent to (regSize)/sizeof(Type);\t\t\u000A\t#define m_HSIZE_v_v4_2048bit (size_t) ((HSIZE + m_elements_per_vector_v4_2048bit - 1) / m_elements_per_vector_v4_2048bit)\u000A    #define HSIZE_hashMap_v4_v4_2048bit (size_t) (m_elements_per_vector_v4_2048bit * m_HSIZE_v_v4_2048bit)\t\u000A\u000A    // define additional unroll factor vor load2048bit_virtual_work_4x16_ v1-v5\u000A    #define outerUnroll (int) (regSize/inner_regSize)               // should be 4  in current config\u000A    #define innerUnroll (int) (elements_per_inner_register)         // should be 16 in current config\u000A\t\t\t\u000A/////////////////////////////////////////////////////////////\u000A\u000A\u000A\u000A\u000A \t\u000A////////////////////////////////////////////////////////////////////////////////\u000A////////////////////////////////////////////////////////////////////////////////\u000A\u000A#endif      // GLOBAL_SETTINGS_HPP_"}, {"path":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/helper/helper_kernel.cpp", "name":"helper_kernel.cpp", "has_active_debug_locs":false, "absName":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/helper/helper_kernel.cpp", "content":"#include<stdio.h>\u000A#include<stdlib.h>\u000A#include<stdint.h>\u000A\u000A#include \"helper_kernel.hpp\"\u000A#include \"../config/global_settings.hpp\"\u000A\u000Ausing namespace std;\u000A\u000A// simple multiplicative hashing function\u000Aunsigned int hashx(int key, int selectable_HSIZE) {\u000A    return ((unsigned long)((unsigned int)1300000077*key)* selectable_HSIZE)>>32;\u000A}\u000A\u000A// ####################\u000A// OLD FUNCTIONS - in current version not used anymore\u000A// ####################\u000A\u000A/**\t\u000A* adaption of c++ pow-function from cmath:\u000A* pow(double base, double exponent);\u000A*\u000A* own function calculate : result = x^a\u000A* return an uint32_t value -> in this project suitable for use within 64-element registers\u000A*/\u000Auint32_t exponentiation_primitive_uint32_t(int x, int a) {\u000A\tuint32_t res = 1;\u000A\tif (a == 0) {\u000A\t\treturn res;\u000A\t} else {\u000A\t\tfor (int i=1; i<=a; i++) {\u000A\t\t\tres = res * x;\u000A\t\t}\u000A\t\treturn res;\u000A\t}\u000A}\u000A\u000A/**\t\u000A* adaption of c++ pow-function from cmath:\u000A* pow(double base, double exponent);\u000A*\u000A* own function calculate : result = x^a\u000A* return an uint64_t value -> in this project suitable for use within 64-element registers\u000A*/\u000Auint64_t exponentiation_primitive_uint64_t(int x, int a) {\u000A\tuint64_t res = 1;\u000A\tif (a == 0) {\u000A\t\treturn res;\u000A\t} else {\u000A\t\tfor (int i=1; i<=a; i++) {\u000A\t\t\tres = res * x;\u000A\t\t}\u000A\t\treturn res;\u000A\t}\u000A}\u000A\u000A/** \u000A * helper function to print an integer in bit-wise notation \u000A * Assumes little endian\u000A * print-result:    p16, p15, p14, p13, p12, p11, p10, p09, p08, p07, p06, p05, p04, p03, p02, p01\u000A * usage: printBits(sizeof(nameOfMask), &nameOfMask);\u000A */\u000Avoid printBits(size_t const size, void const * const ptr) {\u000A    unsigned char *b = (unsigned char*) ptr;\u000A    unsigned char byte;\u000A    int i, j;\u000A    \u000A    for (i = size-1; i >= 0; i--) {\u000A        for (j = 7; j >= 0; j--) {\u000A            byte = (b[i] >> j) & 1;\u000A            printf(\"%u \", byte);\u000A        }\u000A    }\u000A    puts(\"\");\u000A}"}, {"path":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/helper/helper_kernel.hpp", "name":"helper_kernel.hpp", "has_active_debug_locs":false, "absName":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/helper/helper_kernel.hpp", "content":"#ifndef HELPER_KERNEL_HPP\u000A#define HELPER_KERNEL_HPP\u000A\u000A#include <CL/sycl.hpp>\u000A\u000Ausing namespace std;\u000A\u000Aextern SYCL_EXTERNAL unsigned int hashx(int key, int selectable_HSIZE);\u000A\u000Auint32_t exponentiation_primitive_uint32_t(int x, int a);\u000Auint64_t exponentiation_primitive_uint64_t(int x, int a);\u000Avoid printBits(size_t const size, void const * const ptr);\u000A\u000A#endif  // HELPER_KERNEL_HPP"}, {"path":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/helper/helper_main.cpp", "name":"helper_main.cpp", "has_active_debug_locs":false, "absName":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/helper/helper_main.cpp", "content":"#include <stdio.h>\u000A#include <stdlib.h>\u000A#include <sys/types.h>\u000A#include <time.h>\u000A#include <iostream>\u000A#include <chrono>\u000A#include <algorithm>\u000A#include <array>\u000A#include <iomanip>\u000A#include <chrono>\u000A#include <numeric>\u000A#include <vector>\u000A#include <time.h>\u000A#include <tuple>\u000A#include <utility>\u000A\u000A#include \"helper_main.hpp\"\u000A#include \"../config/global_settings.hpp\"\u000A\u000Ausing namespace std;\u000A\u000Avoid initializeHashMap(uint32_t* hashVec, uint32_t* countVec) {\u000A    //initalize hash array with zeros\u000A    for (int i=0; i<HSIZE;i++) {\u000A        hashVec[i]=0;\u000A        countVec[i]=0;\u000A    }\u000A}\u000A\u000A//validates only total count\u000Avoid validate(uint32_t* hashVec, uint32_t* countVec) {\u000A    uint64_t sum=0;\u000A    for (int i=0; i<HSIZE; i++) {\u000A        if (hashVec[i]>0) {\u000A            sum+=countVec[i];\u000A        }\u000A    }\u000A    std::cout << \"Final result check: compare parameter dataSize against sum of all count values in countVec:\" << std::endl;\u000A    std::cout << dataSize <<\" \" << sum << std::endl;\u000A    std::cout <<\" \" << std::endl;\u000A}\u000A\u000A//validates if every entry has the right number of elements and if elements are missing.\u000Avoid validate_element(uint32_t *data, uint32_t*hashVec, uint32_t* countVec) {\u000A    std::cout << \"Element Validation\\n\";\u000A    size_t errors_found = 0;\u000A    // uint32_t lowest = 0;         // variable not used\u000A    size_t m_id = 0;\u000A    uint32_t *nr_list = new uint32_t[HSIZE];\u000A    uint32_t *nr_count = new uint32_t[HSIZE];\u000A\u000A    for(size_t nr = 0; nr < dataSize; nr++){\u000A        uint32_t value = data[nr];\u000A        bool found = false;\u000A        for(size_t i = 0; i < m_id; i++){\u000A            if(nr_list[i] == value){\u000A                found = true;\u000A                nr_count[i]++;\u000A            }\u000A        }\u000A        if(!found){\u000A            nr_list[m_id] = value;\u000A            nr_count[m_id] = 1;\u000A            m_id++;\u000A        }\u000A    }\u000A\u000A    for(size_t val_id = 0; val_id < m_id; val_id++){\u000A        uint32_t validation_val = nr_list[val_id];\u000A        bool found = false;\u000A        for(size_t hash_id = 0; hash_id < HSIZE; hash_id++){\u000A            uint32_t hash_val = hashVec[hash_id];\u000A            if(hash_val == validation_val){\u000A                found = true;\u000A                if(countVec[hash_id] != nr_count[val_id]){\u000A                    std::cout << \"\\tERROR\\tCount\\t\\t\" << hash_val << \"\\thas a count of \" \u000A                        << countVec[hash_id] << \"\\tbut should have a count of \" \u000A                        << nr_count[val_id] << std::endl;\u000A                    errors_found++;\u000A                }\u000A                break;\u000A            }\u000A        }\u000A        if(!found){\u000A            std::cout << \"\\tERROR\\tMissing\\t\\t\" << validation_val << \"\\tis missing. It has a count of \" \u000A                << nr_count[val_id] << std::endl; \u000A            errors_found++;\u000A        }\u000A    }\u000A    if(errors_found == 1){\u000A        std::cout << \"Element Validation found \" << errors_found << \" Error\\n\";\u000A    }\u000A    else if(errors_found > 1){\u000A        std::cout << \"Element Validation found \" << errors_found << \" Errors\\n\";\u000A    }else{\u000A        std::cout << \"Element Validation didn't find any Errors\\n\";\u000A    }\u000A}"}, {"path":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/helper/helper_main.hpp", "name":"helper_main.hpp", "has_active_debug_locs":false, "absName":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/helper/helper_main.hpp", "content":"#ifndef HELPER_MAIN_HPP\u000A#define HELPER_MAIN_HPP\u000A\u000A#include \"../config/global_settings.hpp\"\u000A\u000Ausing namespace std;\u000A\u000Avoid initializeHashMap(uint32_t* hashVec, uint32_t* countVec);\u000Avoid validate(uint32_t* hashVec, uint32_t* countVec);\u000Avoid validate_element(uint32_t *data, uint32_t*hashVec, uint32_t* countVec);\u000A\u000A/**\u000A  *  Generate a data array with random values between 1 and #distinctValues\u000A  *  The array is dynamically sized. The number of elements corresponds to the value in dataSize.\u000A  * @todo : change data generation function to a function with real random values\u000A  */\u000Atemplate <typename T>\u000Avoid generateData(T* arr) {\u000A    int i;    \u000A    for(i=0;i<dataSize;i+=1){\u000A        arr[i] = 1+ (rand() % distinctValues);\u000A    }\u000A} \u000A\u000A#endif  // HELPER_MAIN_HPP"}, {"path":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "name":"kernel.cpp", "has_active_debug_locs":false, "absName":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.cpp", "content":"#include <stdio.h>\u000A#include <stdlib.h>\u000A#include <sys/types.h>\u000A#include <sys/time.h>\u000A#include <time.h>\u000A#include <immintrin.h>\u000A#include <emmintrin.h>\u000A#include <smmintrin.h>\u000A#include <stdbool.h>\u000A#include <stdint.h>\u000A#include <string.h>\u000A#include <stdio.h>\u000A#include <stdlib.h>\u000A#include <iostream>\u000A#include <stdexcept>\u000A\u000A#include <sycl/ext/intel/fpga_extensions.hpp>\u000A\u000A#include \"kernel.hpp\"\u000A#include \"../config/global_settings.hpp\"\u000A#include \"../helper/helper_kernel.hpp\"\u000A#include \"../primitives/primitives.hpp\"\u000A\u000A#include \"lib/lib.hpp\"\u000A////////////////////////////////////////////////////////////////////////////////\u000A////////////////////////////////////////////////////////////////////////////////\u000A//\tOVERVIEW about functions in kernel.cpp\u000A//\u000A//\tLinearProbingFPGA_variant1() == SoA_v1 -- SIMD for FPGA function v1 -  without aligned_start; version descbribed in paper\u000A// \tLinearProbingFPGA_variant2() == SoA_v2 -- SIMD for FPGA function v2 - first optimization: using aligned_start\u000A//\tLinearProbingFPGA_variant3() == SoA_v3 -- SIMD for FPGA function v3 - with aligned start and approach of using permutexvar_epi32\u000A//\tLinearProbingFPGA_variant4() == SoAoV_v1 -- SIMD for FPGA function v4 - use a vector with elements of type <fpvec<Type, regSize> as hash_map structure \"around\" the registers\u000A// \tLinearProbingFPGA_variant5() == SoA_conflict_v1 -- SIMD for FPGA function v5 - \tsearch in loaded data register for conflicts and add the sum of occurences per element to countVec instead of \u000A//\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tprocess each item individually, even though it occurs multiple times in the currently loaded data\t\t\u000A// \u000A////////////////////////////////////////////////////////////////////////////////\u000A////////////////////////////////////////////////////////////////////////////////\u000A\u000A////////////////////////////////////////////////////////////////////////////////\u000A//// Board globals. Can be changed from command line.\u000A// default to values in pac_s10_usm BSP\u000A#ifndef DDR_CHANNELS\u000A#define DDR_CHANNELS 4\u000A#endif\u000A\u000A#ifndef DDR_WIDTH\u000A#define DDR_WIDTH 64 // bytes (512 bits)\u000A#endif\u000A\u000A#ifndef PCIE_WIDTH\u000A#define PCIE_WIDTH 64 // bytes (512 bits)\u000A#endif\u000A\u000A#ifndef DDR_INTERLEAVED_CHUNK_SIZE\u000A#define DDR_INTERLEAVED_CHUNK_SIZE 4096 // bytes\u000A#endif\u000A\u000Aconstexpr size_t kDDRChannels = DDR_CHANNELS;\t\t\u000Aconstexpr size_t kDDRWidth = DDR_WIDTH;\t\t\t\t\u000Aconstexpr size_t kDDRInterleavedChunkSize = DDR_INTERLEAVED_CHUNK_SIZE;\u000A// constexpr size_t kPCIeWidth = PCIE_WIDTH;\u000A////////////////////////////////////////////////////////////////////////////////\u000A\u000A////////////////////////////////////////////////////////////////////////////////\u000A//// declaration of the classes\u000Aclass kernelV4;\u000A\u000A////////////////////////////////////////////////////////////////////////////////\u000A////////////////////////////////////////////////////////////////////////////////\u000A\u000A/**\u000A * Variant 4 of a hasbased group_count implementation for FPGA.\u000A * The algorithm uses the LinearProbing approach to perform the group-count aggregation.\u000A * @param q device queue\u000A * @param arr_d the input data array\u000A * @param hashVec_d store value of k at position hashx(k)\u000A * @param countVec_d store the count of occurence of k at position hashx(k)\u000A * @param dataSize number of tuples respectively elements in hashVec[] and countVec[]\t\t\t\t// global defined, not part of paramater list anymore\u000A * @param HSIZE HashSize (corresponds to size of hashVec[] and countVec[])\t\t\t\t\t\t\t// global defined, not part of paramater list anymore\u000A * @param size = number_CL*16 with number_CL = number_CL_buckets * (4096/16);\u000A * @param m_elements_per_vector_v4_2048bit = elements_per_register\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// global defined, not part of paramater list anymore\u000A * @param m_HSIZE_v_v4_2048bit = (HSIZE + m_elements_per_vector_v4_2048bit - 1) / m_elements_per_vector_v4_2048bit;\t\t\t// global defined, not part of paramater list anymore\u000A * @param HSIZE_hashMap_v4_v4_2048bit = m_elements_per_vector_v4_2048bit * m_HSIZE_v_v4_2048bit\t\t\t\t\t\t\t\t// global defined, not part of paramater list anymore\u000A */\u000Avoid LinearProbingFPGA_variant4(queue& q, uint32_t *arr_d, uint32_t *hashVec_d, uint32_t *countVec_d, size_t size) {\u000A////////////////////////////////////////////////////////////////////////////////\u000A//// Check global board settings (regarding DDR4 config), global parameters & calculate iterations parameter\u000A\tstatic_assert(kDDRWidth % sizeof(int) == 0);\u000A  \tstatic_assert(kDDRInterleavedChunkSize % sizeof(int) == 0);\t\t\t\t\t\t\t\u000A\u000A\tconstexpr size_t kValuesPerInterleavedChunk = kDDRInterleavedChunkSize / sizeof(Type);\u000A\tconstexpr size_t kValuesPerLSU = kDDRWidth / sizeof(Type);\t\t\u000A\tstatic_assert(kValuesPerInterleavedChunk % kValuesPerLSU == 0);\u000A\u000A\tconstexpr size_t kNumLSUs = kDDRChannels;  \u000A\tconstexpr size_t kIterationsPerChunk = kValuesPerInterleavedChunk / kValuesPerLSU;    \u000A\u000A\t// ensure size is nice\u000A\tassert(size % kValuesPerInterleavedChunk == 0);\u000A\tassert(size % kNumLSUs == 0);\u000A\u000A\t// ensure dataSize is nice\u000A\tassert(dataSize % elements_per_register == 0);\u000A\tassert(dataSize % kValuesPerLSU == 0);\u000A\tassert(dataSize % kNumLSUs == 0);   \u000A\u000A\tsize_t total_chunks = size / kValuesPerInterleavedChunk;\u000A\tsize_t chunks_per_lsu = total_chunks / kNumLSUs;\u000A\t// calculation of iterations; value could be bigger than dataSize/elements_per_register\u000A\tconst size_t iterations = chunks_per_lsu * kIterationsPerChunk;  \u000A\t\u000A\t/** \u000A\t * const size_t iterations =  loops;\u000A\t * Update: We don't use this simple calculation of iterations anymore since we load data with 4 DMA controllers in parallel.\u000A\t * Instead we use the iterations_calculated = 2.500.032 (our \"simple\" iterations=loops=2.500.000 would be smaller)\u000A\t * This prevents the \"losing\" of some values at the end of the input array, which is caused by the fact that the four DMA controllers \u000A\t * only ever load from their own 4k pages. This leads to small offsets, which require a slightly higher number of iterations. \u000A\t*/\u000A\u000A\t// ensure global defined regSize and inner_regSize is nice\u000A\tassert(regSize == 256);\u000A\tassert(inner_regSize == 64);\u000A////////////////////////////////////////////////////////////////////////////////\u000A\u000A////////////////////////////////////////////////////////////////////////////////\u000A//// starting point of the logic of the algorithm\u000A\tq.submit([&](handler& h) {\u000A\u000A\t\th.single_task<kernelV4>([=]() [[intel::kernel_args_restrict]] {\u000A\u000A\t\t\tdevice_ptr<Type> input(arr_d);\u000A\t\t\tdevice_ptr<Type> hashVec_globalMem(hashVec_d);\u000A\t\t\tdevice_ptr<Type> countVec_globalMem(countVec_d);\u000A\u000A\t\t\t////////////////////////////////////////////////////////////////////////////////\u000A\t\t\t//// declare some basic masks and arrays\u000A\t\t\tType one = 1;\u000A\t\t\tType zero = 0;\u000A\t\t\tfpvec<Type, regSize> oneMask = set1<Type, regSize>(one);\u000A\t\t\tfpvec<Type, regSize> zeroMask = set1<Type, regSize>(zero);\u000A\t\t\t////////////////////////////////////////////////////////////////////////////////\u000A\t\t\t////////////////////////////////////////////////////////////////////////////////\u000A\t\t\t\u000A\t\t\t////////////////////////////////////////////////////////////////////////////////\u000A\t\t\t//// declare private variables for hashVec & countVec\u000A\t\t\t/* The Intel oneAPI DPC++/C++ Compiler creates a kernel memory in hardware.\u000A\t\t\t* Kernel memory is sometimes referred to as on-chip memory because it is created from\u000A\t\t\t* memory sources (such as RAM blocks) available on the FPGA.\u000A\t\t\t* \u000A\t\t\t* Here we want to create the hashVec and CountVec Arrays inside the kernel with local Memory,\u000A\t\t\t* more accurate with M20K RAM Blocks. This memory type is significantly faster than store/load operations from/to global memory.\u000A\t\t\t* With this change, we only need to write every element of both arrays once to the global memory at the end of the algorithm.\u000A\t\t\t*  \u000A\t\t\t* In the ideal case, the compiler creates both data structures as stall-free. But that depends on whether the algorithm allows it or not.\u000A\t\t\t* Due to the fact that our HSIZE can also be significantly larger, we consciously use M20K RAM blocks instead of MLAB memory, \u000A\t\t\t* since the STRATIX FPGA has approx. 10000 M20K blocks - which corresponds to approx. 20MB and is therefore better suited for larger data structures.\u000A\t\t\t*/\u000A\t\t\t// USING M20K RAM BLOCKS on FPGA to implement hashVec and countVec (embedded memory) and initialize these with zero\u000A\t\t\t[[intel::fpga_memory(\"BLOCK_RAM\")]] std::array<fpvec<Type, regSize>, m_HSIZE_v_v4_2048bit> hash_map;\u000A\t\t\t[[intel::fpga_memory(\"BLOCK_RAM\")]] std::array<fpvec<Type, regSize>, m_HSIZE_v_v4_2048bit> count_map;\u000A\u000A\t\t\t// loading data. On the first exec this should result in only 0 vals. / or better initalize hash_map and count_map with vectors full of 0\u000A\t\t\t#pragma unroll 16\u000A\t\t\tfor(size_t i = 0; i < m_HSIZE_v_v4_2048bit; i++){\u000A\t\t\t\thash_map[i] = zeroMask;\u000A\t\t\t\tcount_map[i] = zeroMask;\u000A\t\t\t}\u000A\t\t\t////////////////////////////////////////////////////////////////////////////////\u000A\t\t\t////////////////////////////////////////////////////////////////////////////////\u000A\u000A\t\t\t/**\u000A\t\t\t * calculate overflow in last register of hash_map and count_map, to prevent errors from storing elements in hash_map[m_HSIZE_v-1] in positions that are >HSIZE \u000A\t\t\t *\t\u000A\t\t\t * due to this approach, the hash_map and count_map can have overall more slots than the value of HSIZE\u000A\t\t\t * set value of positions of the last register that \"overflows\" to a value that is bigger than distinctValues\u000A\t\t\t * These values can't be part of input data array (because inpute only have values between 1 and distinctValues), \u000A\t\t\t * but these slots will be handled as \"no match, but position already filled\" within the algorithm.\u000A\t\t\t * Since only HSIZE values are stored at the end (back to hashVec and countVec), these slots/values are simply dropped at the end.\u000A\t\t\t * This procedure avoids the error that the algorithm stores real values in positions that are not written back later. As a result, values were lost and the end result became incorrect.\u000A\t\t\t */\u000A\t\t\t// define variables and register for overflow calculation\u000A\t\t\tfpvec<Type, regSize> overflow_correction_mask;\u000A\t\t\tType value_bigger_distinctValues;\u000A\t\t\tfpvec<Type, regSize> value_bigger_distinctValues_mask;\u000A\u000A\t\t\t// caculate overflow and mark positions in last register that will be overflow the value of HSIZE\u000A\t\t\tType oferflowUnsigned = (m_HSIZE_v_v4_2048bit * m_elements_per_vector_v4_2048bit) - HSIZE;\u000A\t\t\tif (oferflowUnsigned > 0) {\u000A\t\t\t\toverflow_correction_mask = createOverflowCorrectionMask<Type, regSize>(oferflowUnsigned);\u000A\t\t\t\tvalue_bigger_distinctValues = (Type)(distinctValues+7); \t\u000A\t\t\t\tvalue_bigger_distinctValues_mask = set1<Type, regSize>(value_bigger_distinctValues);\u000A\u000A\t\t\t\thash_map[m_HSIZE_v_v4_2048bit-1] = mask_set1(value_bigger_distinctValues_mask, overflow_correction_mask, zero);\u000A\t\t\t\tcount_map[m_HSIZE_v_v4_2048bit-1] = set1<Type, regSize>(zero);\u000A\t\t\t}\u000A\u000A\t\t\t/** CREATING WRITING MASKS\u000A\t\t\t * \u000A\t\t\t * Following line isn't needed anymore. Instead of zero_cvtu32_mask, please use zeroMask as mask with all 0 and elements_per_register elements!\u000A\t\t\t * fpvec<uint32_t> zero_cvtu32_mask = cvtu32_mask16((uint32_t)0);\t\u000A\t\t\t *\u000A\t\t\t *\told code for creating writing masks:\u000A\t\t\t *\tstd::array<fpvec<uint32_t>, 16> masks {};\u000A\t\t\t *\tfor(uint32_t i = 1; i <= 16; i++){ masks[i-1] = cvtu32_mask16((uint32_t)(1 << (i-1))); }\u000A\t\t\t *\u000A\t\t\t * new solution is working with (variable) regSize and elements_per_register per register (e.g. 256 byte and 64 elements per register)\u000A\t\t\t * It generates a matrix of the required size according to the parameters used.  \u000A\t\t\t */\u000A\t\t\t[[intel::fpga_register]] std::array<fpvec<Type, regSize>, (regSize/sizeof(Type))> masks;\u000A\t\t\tmasks = cvtu32_create_writeMask_Matrix<Type, regSize>();\u000A\u000A\t\t\t/**\u000A\t\t\t * ! ATTENTION - changed indizes (compared to the first AVX512 implementation) !\u000A\t\t\t * mask with only 0 => zero_cvtu32_mask\u000A\t\t\t * masks = array of 16 masks respectively fpvec<uint32_t> with one 1 at unique positions \u000A\t\t\t *\u000A\t\t\t * calculation of free position is reworked\u000A\t\t\t * old approach: uint32_t pos = __builtin_ctz(checkForFreeSpace) + 1;\u000A\t\t\t * -> omit +1, because masks with only 0 at every position is outsourced to zero_cvtu32_mask --> zeroMask is used instead                \u000A\t\t\t */\u000A\u000A\t\t\t// #########################################\u000A\t\t\t// #### START OF FPGA parallelized part ####\u000A\t\t\t// #########################################\u000A\t\t\t// define dataVec register\u000A\t\t\tfpvec<Type, regSize> dataVec;\u000A\u000A\t\t\t// iterate over input data with a SIMD register size of regSize bytes (elements_per_register elements)\u000A\t\t\t#pragma nounroll\t\t// compiler should realize that this loop cannot be unrolled\u000A\t\t\tfor (int i_cnt = 0; i_cnt < iterations; i_cnt++) {\u000A\u000A\t\t\t\t// calculate chunk_idx and chunk_offset for current iteration step\u000A\t\t\t\tconst int i_cnt_const = i_cnt;\u000A\t\t\t\tconst int chunk_idx = i_cnt_const / kIterationsPerChunk;\u000A\t\t\t\tconst int chunk_offset = i_cnt_const % kIterationsPerChunk;\u000A\u000A\t\t\t\t// Load complete CL (register) in one clock cycle (same for PCIe and DDR4)\u000A\t\t\t\tdataVec = maxLoad_per_clock_cycle<Type, regSize>(input, kNumLSUs, kValuesPerLSU, chunk_idx, kValuesPerInterleavedChunk, chunk_offset);\u000A\u000A\t\t\t\t// iterate over input data / always step by step through the currently 16 (or #elements_per_register) loaded elements\u000A\t\t\t\t// @param p current element of input data array\u000A\t\t\t\t// int p = 0;\u000A\t\t\t\t// while (p < elements_per_register) {\u000A\t\t\t\tfor(int p=0; p<elements_per_register; p++) {\u000A\t\t\t\t\tType inputValue = dataVec.elements[p];\u000A\t\t\t\t\tType hash_key = hashx(inputValue,m_HSIZE_v_v4_2048bit);\u000A\t\t\t\t\tfpvec<Type, regSize> broadcastCurrentValue = set1<Type, regSize>(inputValue);\u000A\u000A\t\t\t\t\twhile(1) {\u000A\t\t\t\t\t\t// compare vector with broadcast value against vector with following elements for equality\u000A\t\t\t\t\t\tfpvec<Type, regSize> compareRes = cmpeq_epi32_mask(broadcastCurrentValue, hash_map[hash_key]);\u000A\u000A\t\t\t\t\t\t// found match\u000A\t\t\t\t\t\tif (mask2int(compareRes) != 0) {\u000A\t\t\t\t\t\t\tcount_map[hash_key] = mask_add_epi32(count_map[hash_key], compareRes, count_map[hash_key], oneMask);\u000A\t\t\t\t\t\t\t\tbreak;\u000A\t\t\t\t\t\t} else { // no match found\u000A\t\t\t\t\t\t\t// deterime free position within register\u000A\t\t\t\t\t\t\tfpvec<Type, regSize> checkForFreeSpace = cmpeq_epi32_mask(zeroMask, hash_map[hash_key]);\u000A\u000A\t\t\t\t\t\t\tif(mask2int(checkForFreeSpace) != 0) {                // CASE B1   \u000A\t\t\t\t\t\t\t\tType pos = ctz_onceBultin(checkForFreeSpace);\u000A\t\t\t\t\t\t\t\t//store key\u000A\t\t\t\t\t\t\t\thash_map[hash_key] = mask_set1<Type, regSize>(hash_map[hash_key], masks[pos], inputValue);\u000A\t\t\t\t\t\t\t\t//set count to one\u000A\t\t\t\t\t\t\t\tcount_map[hash_key] = mask_set1<Type, regSize>(count_map[hash_key], masks[pos], (Type)1);\u000A\t\t\t\t\t\t\t\tbreak;\u000A\t\t\t\t\t\t\t}   else    { // CASE B2\u000A\t\t\t\t\t\t\t\t// hash_key = (hash_key + 1) % m_HSIZE_v;\u000A\t\t\t\t\t\t\t\thash_key = (hash_key + 1);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\u000A\t\t\t\t\t\t\t\tif (hash_key >= m_HSIZE_v_v4_2048bit) {\u000A\t\t\t\t\t\t\t\t\thash_key = hash_key-m_HSIZE_v_v4_2048bit;\u000A\t\t\t\t\t\t\t\t}\t\u000A\t\t\t\t\t\t\t}\u000A\t\t\t\t\t\t}\u000A\t\t\t\t\t}\u000A\t\t\t\t}\t\t\t\t\u000A\t\t\t}\u000A\t\t\t\t\u000A\t\t\t// #######################################\u000A\t\t\t// #### END OF FPGA parallelized part ####\u000A\t\t\t// #######################################\u000A\u000A\t\t\t// store data from hash_map & count_map back to global memory\t\u000A\t\t\t// memcpy(hashVec_globalMem, hash_map, HSIZE * sizeof(Type));\u000A\t\t\t// memcpy(countVec_globalMem, hash_map, HSIZE * sizeof(Type));\t\t--> will be handled as for-loop with #pragma unroll through the compiler -> not working for large HSIZE\u000A\t\t\tfor(size_t i = 0; i < m_HSIZE_v_v4_2048bit; i++){\u000A\t\t\t\tsize_t h = i * m_elements_per_vector_v4_2048bit;\u000A\t\t\t\tstore_epi32(hashVec_globalMem, h, hash_map[i]);\u000A\t\t\t\tstore_epi32(countVec_globalMem, h, count_map[i]);\u000A\t\t\t}\u000A\t\t});\u000A\t}).wait();\u000A}   \u000A//// end of LinearProbingFPGA_variant4()\u000A////////////////////////////////////////////////////////////////////////////////"}, {"path":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.hpp", "name":"kernel.hpp", "has_active_debug_locs":false, "absName":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/kernel.hpp", "content":"#ifndef KERNEL_HPP\u000A#define KERNEL_HPP\u000A\u000A#include <CL/sycl.hpp>\u000A#include <sycl/ext/intel/fpga_extensions.hpp>\u000A\u000A#include \"lib/lib.hpp\"\u000A#include \"../config/global_settings.hpp\"\u000A#include \"../primitives/primitives.hpp\"\u000A\u000Ausing namespace sycl;\u000A\u000Aclass kernelV4;\u000A\u000A\u000Avoid LinearProbingFPGA_variant4(queue& q, uint32_t *arr_d, uint32_t *hashVec_d, uint32_t *countVec_d, size_t size);\u000A\u000A\u000A#endif  // KERNEL_HPP"}, {"path":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/lib/lib.hpp", "name":"lib.hpp", "has_active_debug_locs":false, "absName":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/lib/lib.hpp", "content":"//==============================================================\u000A// Copyright Intel Corporation\u000A//\u000A// SPDX-License-Identifier: MIT\u000A// =============================================================\u000A\u000A// SYCL functions\u000ASYCL_EXTERNAL float SyclSquare(float);\u000ASYCL_EXTERNAL float SyclSqrt(float);\u000ASYCL_EXTERNAL int SyclMult(int x, int y);\u000A\u000ASYCL_EXTERNAL std::array<int, 16> SyclBubbleSort( std::array<int, 16> a );\u000A\u000A\u000A// RTL functions\u000ASYCL_EXTERNAL extern \"C\" unsigned RtlByteswap(unsigned x);\u000ASYCL_EXTERNAL extern \"C\" unsigned AdderUint(unsigned int a, unsigned int b );\u000A"}, {"path":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/lib/lib_rtl_model.cpp", "name":"lib_rtl_model.cpp", "has_active_debug_locs":false, "absName":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/lib/lib_rtl_model.cpp", "content":"//==============================================================\u000A// Copyright Intel Corporation\u000A//\u000A// SPDX-License-Identifier: MIT\u000A// =============================================================\u000A#include <CL/sycl.hpp>\u000A\u000ASYCL_EXTERNAL extern \"C\" unsigned RtlByteswap(unsigned x) {\u000A  return x << 16 | x >> 16; \u000A}\u000A"}, {"path":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/lib/lib_rtl_model_add.cpp", "name":"lib_rtl_model_add.cpp", "has_active_debug_locs":false, "absName":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/lib/lib_rtl_model_add.cpp", "content":"//==============================================================\u000A// Copyright Intel Corporation\u000A//\u000A// SPDX-License-Identifier: MIT\u000A// =============================================================\u000A\u000A/*\u000A###############################\u000A## Created: Intel Corporation \u000A##          Christian Faerber\u000A##          PSG CE EMEA TS-FAE \u000A##          June 2022\u000A###############################\u000A*/\u000A\u000A#include <CL/sycl.hpp>\u000A\u000ASYCL_EXTERNAL extern \"C\" unsigned AdderUint(unsigned int a, unsigned int b) {\u000A  return a + b; \u000A}\u000A"}, {"path":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/lib/lib_sycl.cpp", "name":"lib_sycl.cpp", "has_active_debug_locs":false, "absName":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/lib/lib_sycl.cpp", "content":"//==============================================================\u000A// Copyright Intel Corporation\u000A//\u000A// SPDX-License-Identifier: MIT\u000A// =============================================================\u000A#include <CL/sycl.hpp>\u000A#include <sycl/ext/intel/fpga_extensions.hpp>\u000A\u000A\u000ASYCL_EXTERNAL float SyclSquare(float x) { return x * x; }\u000ASYCL_EXTERNAL float SyclSqrt(float x) { return sqrt(x); }\u000ASYCL_EXTERNAL int SyclMult(int x, int y) { return x * y; }\u000A\u000A#define N 16\u000A\u000ASYCL_EXTERNAL std::array<int, 16> SyclBubbleSort(\u000A        std::array<int, 16> x\u000A){\u000A\u000A        // Input registers\u000A        int a[N];\u000A        \u000A        #pragma unroll\u000A        for (int i = 0; i < N; i++)\u000A                a[i] = x[i];\u000A\u000A        // bubble sort\u000A        int tmp = 0;\u000A        \u000A        #pragma unroll\u000A        for (int i = 0; i < N; ++i) {\u000A            #pragma unroll\u000A            for (int j = 0; j < N - i - 1; ++j) {\u000A                if (a[j] > a[j + 1]) {\u000A                    tmp = a[j];\u000A                    a[j] = a[j + 1];\u000A                    a[j + 1] = tmp;\u000A                }\u000A            }\u000A        }\u000A\u000A        // Output registers\u000A        std::array<int, 16> a0;\u000A        \u000A        #pragma unroll\u000A        for (int i = 0; i < N; i++)\u000A                a0[i] = a[i];\u000A    \u000A        return a0;\u000A}\u000A\u000A"}, {"path":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/main.cpp", "name":"main.cpp", "has_active_debug_locs":false, "absName":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/load2048bit_permanent_v4/main.cpp", "content":"/*\u000A###############################\u000A## Created: Eric Stange\u000A##          TU Dresden\u000A##          January 2023\u000A## \u000A## Used template from:\u000A##          Intel Corporation \u000A##          Christian Faerber\u000A##          PSG CE EMEA TS-FAE \u000A##          June 2022\u000A###############################\u000A\u000A* This is a hashbased group count implementation using the linear probing approach.\u000A* The Intel Intrinsics from the previous AVX512-based implementation were re-implemented without AVX512.\u000A* This code is intended to be able to run in parallel with the Intel OneAPI on FPGAs.\u000A*/\u000A////////////////////////////////////////////////////////////////////////////////\u000A////////////////////////////////////////////////////////////////////////////////\u000A//\tOVERVIEW about functions in kernel.cpp\u000A//\u000A//\tLinearProbingFPGA_variant1() == SoA_v1 -- SIMD for FPGA function v1 -  without aligned_start; version descbribed in paper\u000A// \tLinearProbingFPGA_variant2() == SoA_v2 -- SIMD for FPGA function v2 - first optimization: using aligned_start\u000A//\tLinearProbingFPGA_variant3() == SoA_v3 -- SIMD for FPGA function v3 - with aligned start and approach of using permutexvar_epi32\u000A//\tLinearProbingFPGA_variant4() == SoAoV_v1 -- SIMD for FPGA function v4 - use a vector with elements of type <fpvec<Type, regSize> as hash_map structure \"around\" the registers\u000A// \tLinearProbingFPGA_variant5() == SoA_conflict_v1 -- SIMD for FPGA function v5 - \tsearch in loaded data register for conflicts and add the sum of occurences per element to countVec instead of \u000A//\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tprocess each item individually, even though it occurs multiple times in the currently loaded data\t\t\u000A// \u000A////////////////////////////////////////////////////////////////////////////////\u000A////////////////////////////////////////////////////////////////////////////////\u000A#include <stdio.h>\u000A#include <stdlib.h>\u000A#include <sys/types.h>\u000A#include <time.h>\u000A#include <iostream>\u000A#include <chrono>\u000A#include <algorithm>\u000A#include <array>\u000A#include <iomanip>\u000A#include <numeric>\u000A#include <vector>\u000A#include <time.h>\u000A#include <tuple>\u000A#include <utility>\u000A#include <CL/sycl.hpp>\u000A#include <sycl/ext/intel/fpga_extensions.hpp>\u000A\u000A// Time\u000A#include <sys/time.h>\u000A// Sleep\u000A#include <unistd.h>\u000A\u000A#include \"../config/global_settings.hpp\"\u000A#include \"kernel.hpp\"\u000A#include \"../helper/helper_main.hpp\"\u000A\u000A\u000Ausing namespace sycl;\u000Ausing namespace std::chrono;\u000A\u000A////////////////////////////////////////////////////////////////////////////////\u000A//// Board globals. Can be changed from command line.\u000A// default to values in pac_s10_usm BSP\u000A                         \u000A#ifndef DDR_CHANNELS\u000A#define DDR_CHANNELS 4\u000A#endif\u000A\u000A#ifndef DDR_WIDTH\u000A#define DDR_WIDTH 64 // bytes (512 bits)\u000A#endif\u000A\u000A#ifndef PCIE_WIDTH\u000A#define PCIE_WIDTH 64 // bytes (512 bits)\u000A#endif\u000A\u000A#ifndef DDR_INTERLEAVED_CHUNK_SIZE\u000A#define DDR_INTERLEAVED_CHUNK_SIZE 4096 // bytes\u000A#endif\u000A\u000Aconstexpr size_t kDDRInterleavedChunkSize = DDR_INTERLEAVED_CHUNK_SIZE;\u000A\u000A////////////////////////////////////////////////////////////////////////////////\u000A////////////////////////////////////////////////////////////////////////////////\u000A\u000A////////////////////////////////////////////////////////////////////////////////\u000A//// Forward declare functions\u000Atemplate<typename T>\u000Abool validate(T *in_host, T *out_host, size_t size);\u000Avoid exception_handler(exception_list exceptions);\u000A////////////////////////////////////////////////////////////////////////////////\u000A////////////////////////////////////////////////////////////////////////////////\u000A\u000A// main\u000Aint  main(int argc, char** argv){\u000A\u000A    // make default input size enough to hide overhead\u000A    #ifdef FPGA_EMULATOR\u000A    long size = kDDRInterleavedChunkSize * 4;\u000A    #else\u000A    long size = kDDRInterleavedChunkSize * 16384;\u000A    #endif\u000A\u000A    // the device selector\u000A    #ifdef FPGA_EMULATOR\u000A    ext::intel::fpga_emulator_selector selector;\u000A    #else\u000A    ext::intel::fpga_selector selector;\u000A    #endif\u000A\u000A    // create the device queue\u000A    // auto props = property_list{property::queue::enable_profiling()};\u000A    auto props = property_list{};\u000A    queue q(selector, exception_handler, props);\u000A\u000A    // make sure the device supports USM device allocations\u000A    device d = q.get_device();\u000A    if (!d.get_info<info::device::usm_device_allocations>()) {\u000A        std::cerr << \"ERROR: The selected device does not support USM device\"\u000A                << \" allocations\\n\";\u000A        std::terminate();\u000A    }\u000A    if (!d.get_info<info::device::usm_host_allocations>()) {\u000A        std::cerr << \"ERROR: The selected device does not support USM host\"\u000A                << \" allocations\\n\";\u000A        std::terminate();\u000A    }\u000A\u000A    /**\u000A     * calculate parameters for memory allocation\u000A     *\u000A     * If a second parameter is passed when running the main.fpga file, \u000A     * use this as \"size\", otherwise define the parameter \"size\" using the value of\u000A     * variable dataSize, which is defined in global_settings.hpp.\u000A    */ \u000A    if ( argc != 2 ) { // argc should be 2 for correct execution\u000A        size = dataSize;\u000A\t} else {\u000A\t\tsize = atoi(argv[1]);\u000A\t}\u000A    printf(\"Input vector length (atoi(argv[1])): %zd \\n\", size);\u000A\u000A\u000A    size_t number_CL_buckets = 0;\u000A    size_t number_CL = 0;\u000A\t\u000A\tif(size % (4096) == 0)\u000A\t{\u000A\t\tnumber_CL_buckets = size / (4096);\u000A\t}\u000A\telse \u000A\t{\u000A\t\tnumber_CL_buckets = size / (4096) + 1;\u000A\t}\u000A\t\u000A    number_CL = number_CL_buckets * (4096/multiplier);\u000A    \u000A\tprintf(\"Number CL buckets: %zd \\n\", number_CL_buckets);\u000A    printf(\"Number CLs: %zd \\n\", number_CL);\u000A\u000A    // print global settings\u000A    std::cout <<\"==============================================\"<<std::endl;\u000A    std::cout <<\"============= Program Start ==================\"<<std::endl; \u000A    std::cout <<\"==============================================\"<<std::endl;    \u000A    std::cout << \"Global configuration:\"<<  std::endl;\u000A    std::cout << \"distinctValues | scale-facor | dataSize : \"<<distinctValues<<\" | \"<<scale<<\" | \"<<dataSize<< std::endl;\u000A    // print hashsize of current settings\u000A    std::cout << \"Configured HSIZE : \" << HSIZE << std::endl;\u000A    std::cout << \"Configured DATATYPE within registers : \" << typeid(Type).name() << std::endl;\u000A    std::cout << \"Configured register size (regSize) for data transfer : \" << regSize << \" byte (= \" << (regSize*8) << \" bit)\" << std::endl;\u000A   \u000A    // Define for Allocate input/output data in pinned host memory\u000A    // Used in all three tests, for convenience\u000A    Type *arr_h, *arr_d; \u000A    Type *hashVec_h, *hashVec_d;\u000A    Type *countVec_h, *countVec_d;\u000A\u000A////////////////////////////////////////////////////////////////////////////////\u000A////////////////////////////////////////////////////////////////////////////////\u000A//// Forward declare LinearProbingFPGA_variant4()\u000A    std::cout <<\"==============================================\"<<std::endl;\u000A    std::cout <<\"==============================================\"<<std::endl;\u000A\tprintf(\"\\n \\n ### START of Linear Probing for FPGA - SIMD Variant 4 (SoAoV_v1) ### \\n\\n\");\u000A\u000A    // Host buffer \u000A    if ((arr_h = malloc_host<Type>(number_CL*multiplier, q)) == nullptr) {\u000A        std::cerr << \"ERROR: could not allocate space for 'arr_h'\\n\";\u000A        std::terminate();\u000A    }\u000A    if ((hashVec_h = malloc_host<Type>(HSIZE, q)) == nullptr) {\u000A        std::cerr << \"ERROR: could not allocate space for 'hashVec_h'\\n\";\u000A        std::terminate();\u000A    }\u000A    if ((countVec_h = malloc_host<Type>(HSIZE, q)) == nullptr) {\u000A        std::cerr << \"ERROR: could not allocate space for 'countVec_h'\\n\";\u000A        std::terminate();\u000A    }  \u000A\u000A    // Device buffer  \u000A    if ((arr_d = malloc_device<Type>(number_CL*multiplier, q)) == nullptr) {\u000A        std::cerr << \"ERROR: could not allocate space for 'arr_d'\\n\";\u000A        std::terminate();\u000A    }\u000A    if ((hashVec_d = malloc_device<Type>(HSIZE_hashMap_v4_v4_2048bit, q)) == nullptr) {\u000A        std::cerr << \"ERROR: could not allocate space for 'hashVec_d'\\n\";\u000A        std::terminate();\u000A    }\u000A    if ((countVec_d = malloc_device<Type>(HSIZE_hashMap_v4_v4_2048bit, q)) == nullptr) {\u000A        std::cerr << \"ERROR: could not allocate space for 'countVec_d'\\n\";\u000A        std::terminate();\u000A    }  \u000A\u000A    // check if memory for input array and HashTable (hashVec and countVec) is allocated correctly (on host)\u000A    if (arr_h != NULL) {\u000A        std::cout << \"Memory allocated - \" << dataSize << \" values, between 1 and \" << distinctValues << std::endl;\u000A    } else {\u000A        std::cout << \"Memory not allocated!\" << std::endl;\u000A    }\u000A    if (hashVec_h != NULL ||  countVec_h != NULL) {\u000A        std::cout << \"HashTable allocated - \" <<HSIZE<< \" values\" << std::endl;\u000A    } else {\u000A        std::cout << \"HashTable not allocated\" << std::endl;\u000A    }\u000A\u000A    // Init input buffer\u000A    generateData<Type>(arr_h);    \u000A    std::cout <<\"Generation of initial data done.\"<< std::endl; \u000A\u000A    // Copy input host buffer to input device buffer\u000A    q.memcpy(arr_d, arr_h, number_CL*multiplier * sizeof(Type));\u000A    q.wait();\t\t\u000A\u000A    // init HashMap\u000A    initializeHashMap(hashVec_h,countVec_h);\u000A    \u000A    // Copy with zero initialized HashMap (hashVec, countVec) from host to device\u000A    q.memcpy(hashVec_d, hashVec_h, HSIZE * sizeof(Type));\u000A    q.wait();\u000A    q.memcpy(countVec_d, countVec_h, HSIZE * sizeof(Type));\u000A    q.wait();\u000A\u000A    // track timing information, in ms\u000A    double pcie_time_v4=0.0;\u000A\u000A//SIMD for FPGA function v4 (SoAoV_v1)\u000A    try {\u000A        ////////////////////////////////////////////////////////////////////////////\u000A        std::cout <<\"==============================\"<<std::endl;\u000A        std::cout <<\"Kernel-Start : LinearProbingFPGA_variant4() == SoAoV_v1 -- SIMD for FPGA function v4:\"<<std::endl;\u000A        std::cout << \"Running on FPGA Hardware with a dataSize of \" << dataSize << \" values!\" << std::endl;\u000A\u000A        // dummy run to program FPGA, dont care first run for measurement\u000A        LinearProbingFPGA_variant4(q, arr_d, hashVec_d, countVec_d, number_CL*multiplier);\u000A\u000A        // Re-Initialize HashMap after dummy run\u000A        initializeHashMap(hashVec_h,countVec_h);\u000A        q.memcpy(hashVec_d, hashVec_h, HSIZE * sizeof(Type));\u000A        q.wait();\u000A        q.memcpy(countVec_d, countVec_h, HSIZE * sizeof(Type));\u000A        q.wait();\u000A\u000A        // measured run on FPGA\u000A        auto begin_v4 = std::chrono::high_resolution_clock::now();\u000A        LinearProbingFPGA_variant4(q, arr_d, hashVec_d, countVec_d, number_CL*multiplier);\u000A        auto end_v4 = std::chrono::high_resolution_clock::now();\u000A        duration<double, std::milli> diff_v4 = end_v4 - begin_v4;\u000A\u000A        std::cout<<\"Kernel runtime of function LinearProbingFPGA_variant4(): \"<< (diff_v4.count()) << \" ms.\" <<std::endl;\u000A        std::cout <<\"==============================\"<<std::endl;\u000A        pcie_time_v4=diff_v4.count();\u000A        ////////////////////////////////////////////////////////////////////////////\u000A    } \u000A    catch (sycl::exception const& e) {\u000A        std::cout << \"Caught a synchronous SYCL exception: \" << e.what() << \"\\n\";\u000A        std::terminate();\u000A    }   \u000A\u000A    // Copy output device buffer to output host buffer \u000A    q.memcpy(hashVec_h, hashVec_d, HSIZE * sizeof(Type));\u000A    q.wait();  \u000A    q.memcpy(countVec_h, countVec_d, HSIZE * sizeof(Type));\u000A    q.wait();   \u000A    \u000A    std::cout << \"Value in variable dataSize: \" << dataSize << std::endl;\u000A    std::cout<< \" \" <<std::endl;\u000A\u000A    // check result for correctness\u000A    validate(hashVec_h, countVec_h);\u000A//  validate_element(arr_h, hashVec_h, countVec_h);\u000A    std::cout<< \" \" <<std::endl;\u000A\u000A    // free USM memory\u000A    sycl::free(arr_h, q);\u000A    sycl::free(hashVec_h, q);\u000A    sycl::free(countVec_h, q);\u000A    \u000A    sycl::free(arr_d, q);\u000A    sycl::free(hashVec_d, q);\u000A    sycl::free(countVec_d, q);   \u000A\u000A    // print result\u000A    std::cout << \"Final Evaluation of the Throughput: \" <<std::endl;\u000A    double input_size_mb_v4 = size * sizeof(Type) * 1e-6;\u000A\tstd::cout << \"Input_size_mb: \" << input_size_mb_v4 <<std::endl;\u000A    std::cout << \"HOST-DEVICE Throughput: \" << (input_size_mb_v4 / (pcie_time_v4 * 1e-3)) << \" MB/s\\n\";\u000A\u000A    std::cout <<\" ### End of Linear Probing for FPGA - SIMD Variant 4 (SoAoV_v1) ### \"<<std::endl;\u000A    std::cout <<\"==============================================\"<<std::endl;\u000A    std::cout <<\"==============================================\"<<std::endl;\u000A//// end of LinearProbingFPGA_variant4()\u000A////////////////////////////////////////////////////////////////////////////////\u000A\u000A}\u000A// end of main()\u000A\u000Avoid exception_handler (exception_list exceptions) {                     \u000A  for (std::exception_ptr const& e : exceptions) {\u000A    try {\u000A        std::rethrow_exception(e);\u000A    } catch(sycl::exception const& e) {\u000A        std::cout << \"Caught asynchronous SYCL exception:\\n\"\u000A            << e.what() << std::endl;\u000A    }\u000A  }\u000A}"}, {"path":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/primitives/primitives.hpp", "name":"primitives.hpp", "has_active_debug_locs":false, "absName":"/home/u177951/FPGA-SIMD-Sandbox/group_count_FPGA/primitives/primitives.hpp", "content":"#ifndef PRIMITIVES_HPP__\u000A#define PRIMITIVES_HPP__\u000A\u000A#include <array>\u000A#include \"../config/global_settings.hpp\"\u000A\u000A/**\u000A * This file contains the scalar primitves of the Intel Intrinsics, which are used \u000A * in the own AVX512-implementations of the hashbased group_count.\u000A * These functions will be used to run the logic of the AVX512 implementations \u000A * on a FPGA within the Intel DevCloud.\u000A *\u000A * Some of these functions are adapted to the peculiarities of our implementation. \u000A * This is usually due to the goal of simplified data processing. \u000A * In some cases, however, the logic of the implemented LinearProbing algorithms required a \"special solution\".\u000A*/\u000A\u000Atemplate<typename T, int B>\u000Astruct fpvec {\u000A    [[intel::fpga_register]] std::array<T, (B/sizeof(T))> elements;\u000A};\u000A\u000A/* // print a fpvec<T> result register\u000A\tfor (int i=0; i<(64/sizeof(T)); i++) {\u000A\t\tstd::cout << reg.elements[i] << \" \";\u000A\t} \u000A*/\u000A\u000A/**\t#1\u000A * serial primitive for Intel Intrinsic:\u000A * _mm512_setzero_epi32\u000A */\u000Atemplate<typename T, int B>\u000Afpvec<T,B> setzero() {\u000A\tauto reg = fpvec<T,B>{};\u000A\tType zero = 0;\u000A\t#pragma unroll\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\treg.elements[i] = zero;\u000A\t}\u000A\treturn reg;\u000A} \u000A\u000A/**\t#2\u000A * serial primitive for Intel Intrinsic:\u000A * __m512i _mm512_setr_epi32 (int e15, int e14, int e13, int e12, \u000A * int e11, int e10, int e9, int e8, int e7, int e6, int e5, int e4, int e3, \u000A * int e2, int e1, int e0)\u000A * \u000A * function will (currently) only be working for arrys with 16 elements of 32bit integers!\u000A */\u000A/** Not used in current code version --> due to limitations regarding dynamic change of size and amount of elements\u000Atemplate<typename T, int B>\u000Afpvec<T> setr_16slot(uint32_t e15, uint32_t e14, uint32_t e13, uint32_t e12, uint32_t e11, uint32_t e10, uint32_t e9,\u000A\tuint32_t e8, uint32_t e7, uint32_t e6, uint32_t e5, uint32_t e4, uint32_t e3, uint32_t e2, uint32_t e1, uint32_t e0) {\u000A\tauto reg = fpvec<T>{};\u000A\treg.elements[0] = e0;\u000A\treg.elements[1] = e1;\u000A\treg.elements[2] = e2;\u000A\treg.elements[3] = e3;\u000A\treg.elements[4] = e4;\u000A\treg.elements[5] = e5;\u000A\treg.elements[6] = e6;\u000A\treg.elements[7] = e7;\u000A\treg.elements[8] = e8;\u000A\treg.elements[9] = e9;\u000A\treg.elements[10] = e10;\u000A\treg.elements[11] = e11;\u000A\treg.elements[12] = e12;\u000A\treg.elements[13] = e13;\u000A\treg.elements[14] = e14;\u000A\treg.elements[15] = e15;\u000A\treturn reg;\u000A}\u000A*/\u000A\u000A/**\t#3\u000A* serial primitive for Intel Intrinsic:\u000A* __m512i _mm512_set1_epi32 (int a)\u000A*\u000A* The original Intrinsic was only for 32-bit integers.\u000A* This implemenation is working with uint32_t & uint64_t, etc.\u000A* But be careful with matching ratio of <Type, B> and related T value which is overhanded to the function!\u000A*/\u000Atemplate<typename T, int B>\u000Afpvec<T,B> set1(T value) {\u000A\tauto reg = fpvec<T,B>{};\u000A\t#pragma unroll\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\treg.elements[i] = value;\u000A\t}\u000A\treturn reg;\u000A}\u000A\u000A/**\t#4\u000A* serial primitive for Intel Intrinsic:\u000A* __mmask16 _cvtu32_mask16 (unsigned int a)\u000A* original description: \"Convert integer value a into an 16-bit mask, and store the result in k.\"*\u000A*/\u000Atemplate<typename T, int B>\u000Afpvec<T,B> cvtu32_mask16(T n) {\u000A\tauto reg = fpvec<T,B>{};\u000A\tint lastElement = ((B/sizeof(T))-1);\u000A\t#pragma unroll\u000A\twhile (lastElement >= 0) {\u000A         // storing remainder in array\u000A        reg.elements[lastElement] = (n >> lastElement) & 0x1;;\u000A\t\tlastElement = lastElement-1;\u000A    }\u000A\treturn reg;\u000A}\u000A\u000A/**\t#4.1\u000A* serial primitive adaption of Intel Intrinsic:\u000A* __mmask16 _cvtu32_mask16 (unsigned int a)\u000A* Function creates array with elements of <fpvec<Type,B>; every element consists of a <fpvec<Type,B> register with all 0 except at position i\u000A* 10000000\u000A* 01000000\u000A* 00100000\u000A* 00010000\u000A* ...\u000A* Function automatically adjusts all sizes depending on the data type and the regSize parameter.\u000A*/\u000Atemplate<typename T, int B>\u000Astd::array<fpvec<T, B>, (B/sizeof(T))> cvtu32_create_writeMask_Matrix() {\u000A\tType zero = 0;\u000A\tType one = 1;\u000A\tstd::array<fpvec<Type, B>, (B/sizeof(T))> result;\u000A\u000A\t#pragma unroll\u000A\tfor(Type i = 0; i < (B/sizeof(T)); i++){\u000A\t\tauto tmp = fpvec<T,B>{};\u000A\t\t#pragma unroll\u000A\t\tfor (int j=0; j<(B/sizeof(T)); j++) {\u000A\t\t\ttmp.elements[j] = zero;\u000A\t\t}\u000A\t\ttmp.elements[i] = one;\u000A\t\tresult[i] = tmp;\u000A\t}\u000A\treturn result;\u000A}\u000A\u000A/**\t#5\u000A* serial primitive for two Intel Intrinsics:\u000A* __m512i _mm512_maskz_loadu_epi32 (__mmask16 k, void const* mem_addr)\u000A* __m512i _mm512_mask_loadu_epi32 (__m512i src, __mmask16 k, void const* mem_addr)\u000A* _mm512_maskz_loadu_epi32\t:\toriginal description: \"Load packed 32-bit integers from memory \u000A*\t\t\t\t\t\t\t\tinto dst using zeromask k (elements are zeroed out when the \u000A*\t\t\t\t\t\t\t\tcorresponding mask bit is not set). mem_addr does not need to \u000A*\t\t\t\t\t\t\t\tbe aligned on any particular boundary.\"\u000A* _mm512_mask_loadu_epi32\t:\toriginal description: \"Load packed 32-bit integers from memory \u000A*\t\t\t\t\t\t\t\tinto dst using writemask k (elements are copied from src when \u000A*\t\t\t\t\t\t\t\tthe corresponding mask bit is not set). \u000A*\t\t\t\t\t\t\t\tmem_addr does not need to be aligned on any particular boundary.\"\u000A*\u000A* customized loadu-function:\u000A* @param writeMask : if bit is set to \"1\" load related item from data\u000A* @param data : array which contains the data which should be loaded\u000A* @param startIndex : first index-position of data from where the data should be loaded\u000A*/\u000Atemplate<typename T, int B>\u000Afpvec<T, B> mask_loadu(fpvec<T,B>& writeMask, std::array<Type, HSIZE>& data, uint32_t startIndex) {\u000A\tauto reg = fpvec<T,B>{};\u000A\t#pragma unroll 16\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\tif (writeMask.elements[i] == 1) {\u000A\t\t\t// old reg.elements[i] = data[(startIndex+i)%HSIZE];\u000A\t\t\treg.elements[i] = data[startIndex+i];\u000A\t\t}\u000A\t}\u000A\treturn reg;\u000A}\u000A\u000A/**\t#5.1\u000A * \u000A * Adapted version of function #5, to load from the buffer, which is used in LinearProbing_v5()\u000A * The used buffer is of type: std::array<Type, elements_per_inner_register>\t<-- parameter are defined in global_settings.hpp\u000A*/\u000Atemplate<typename T, int B>\u000Afpvec<T, B> mask_loadu_from_buffer(fpvec<T,B>& writeMask, std::array<Type, elements_per_inner_register>& data, uint32_t startIndex) {\u000A\tauto reg = fpvec<T,B>{};\u000A\t#pragma unroll\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\tif (writeMask.elements[i] == 1) {\u000A\t\t\t// old reg.elements[i] = data[(startIndex+i)%HSIZE];\u000A\t\t\treg.elements[i] = data[startIndex+i];\u000A\t\t}\u000A\t}\u000A\treturn reg;\u000A}\u000A\u000A/**\t#6\u000A* serial primitive for Intel Intrinsic:\u000A* __mmask16 _mm512_mask_cmpeq_epi32_mask (__mmask16 k1, __m512i a, __m512i b)\u000A* original description: \"Compare packed 32-bit integers in a and b for equality, and store the results in mask vector k \u000A* using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\"\u000A*/\u000Atemplate<typename T, int B>\u000Afpvec<T,B> mask_cmpeq_epi32_mask(fpvec<T,B>& zeroMask, fpvec<T,B>& a, fpvec<T,B>& b) {\u000A\tauto reg = fpvec<T,B>{};\u000A\t#pragma unroll\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\tif (zeroMask.elements[i] == 1) {\u000A\t\t\tif (a.elements[i] == b.elements[i]) {\u000A\t\t\t\treg.elements[i] = 1;\u000A\t\t\t}\t\u000A\t\t}\t\u000A\t}\u000A\treturn reg;\u000A}\u000A\u000A/**\t#7\u000A* serial primitive for Intel Intrinsic:\u000A* __m512i _mm512_mask_add_epi32 (__m512i src, __mmask16 k, __m512i a, __m512i b)\u000A* original description: \"Add packed 32-bit integers in a and b, and store the results in dst using writemask k \u000A* (elements are copied from src when the corresponding mask bit is not set).\"\u000A*/\u000Atemplate<typename T, int B>\u000Afpvec<T,B> mask_add_epi32(fpvec<T,B>& src, fpvec<T,B>& writeMask, fpvec<T,B>& a, fpvec<T,B>& b) {\u000A\tauto reg = fpvec<T,B>{};\u000A\t#pragma unroll\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\tif (writeMask.elements[i] == 1) {\u000A\t\t\treg.elements[i] = a.elements[i] + b.elements[i];\u000A\t\t}\u000A\t\telse {\u000A\t\t\treg.elements[i] = src.elements[i];\u000A\t\t}\u000A\t}\u000A\treturn reg;\u000A}\u000A\u000A/**\t#8\u000A* serial primitive for Intel Intrinsic:\u000A* void _mm512_mask_storeu_epi32 (void* mem_addr, __mmask16 k, __m512i a)\u000A* original description: \"Store packed 32-bit integers from a (=data) into memory using writemask k. \u000A* mem_addr does not need to be aligned on any particular boundary.\"\u000A*\u000A* customized store  - function:\u000A* @param result : array, in which the data is stored, if related bit of writeMask is set to \"1\"\u000A* @param startIndex : first index - position of data from where the data should be stored\u000A* @param writeMask : if bit is set to \"1\" -> store related item from data into result array\u000A* @param data : register-array which contains the data that should be stored\u000A*/\u000Atemplate<typename T, int B>\u000Avoid mask_storeu_epi32(std::array<Type, HSIZE>& result, uint32_t startIndex, fpvec<T,B>& writeMask, fpvec<T,B>& data) {\u000A\t#pragma unroll 16\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\tif (writeMask.elements[i] == 1) {\u000A\t\t\t// result[(startIndex+i)%HSIZE] = data.elements[i];\u000A\t\t\tresult[startIndex+i] = data.elements[i];\u000A\t\t}\u000A\t}\u000A}\u000A\u000A/**\t#9\u000A* serial primitive for Intel Intrinsic:\u000A* int _mm512_mask2int (__mmask16 k1)\u000A* original description: \"Converts bit mask k1 into an integer value, storing the results in dst.\"\u000A* own (simplified implementation):\u000A* \u000A* IMPORTANT: \tThis is an adjustet implementation of the intrinsic mentioned above. \u000A\t\t\t\tThis solution is specially tailored to the logical flow of LinearProbing_v1 - v5 \u000A\t\t\t\tand its functionality is reduced to its necessities.\u000A* @return 1 if at least 1 bit of mask is set;\u000A* @return 0 if no bit of mask is set\u000A*/\u000Atemplate<typename T, int B>\u000AType mask2int(fpvec<T,B>& mask) {\u000A\tType res = 0;\u000A\t#pragma unroll\t\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\tif (mask.elements[i] == 1) {\u000A\t\t\tres = 1;\u000A\t\t}\u000A\t}\u000A\treturn res;\u000A}\u000A\u000A/**\t#9.1\u000A* adaption of Intel Intrinsic:\u000A* int _mm512_mask2int (__mmask16 k1)\u000A* IMPORTANT: \tThis is an own adapted implementation of _mm512_mask2int, which return an uint32_t value\u000A*\t\t\t\tas representation of overhanded mask.\u000A*\t\t\t\tThis function can handle masks up to 32 elements!\u000A*\u000A* @return uint32 value as representation of overhanded mask\u000A* @return 0 if no bit of mask is set\u000A*/\u000Atemplate<typename T, int B>\u000Auint32_t mask2int_uint32_t(fpvec<T,B>& mask) {\u000A\tuint32_t res = 0;\u000A\t#pragma unroll\t\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\tif (mask.elements[i] == 1) {\u000A\t\t\tif (i == 0) {\u000A\t\t\t\tres += 1;\u000A\t\t\t} else {\u000A\t\t\t\tuint32_t tmp = 1;\u000A\t\t\t\t#pragma unroll\u000A\t\t\t\tfor (int j=1; j<=i; j++) {\u000A\t\t\t\t\ttmp = tmp * 2;\u000A\t\t\t\t}\u000A\t\t\t\tres += tmp;\u000A\t\t\t}\u000A\t\t}\u000A\t}\u000A\treturn res;\u000A}\u000A\u000A/**\t#9.2\u000A* adaption of Intel Intrinsic:\u000A* int _mm512_mask2int (__mmask16 k1)\u000A* IMPORTANT: \tThis is an own adapted implementation of _mm512_mask2int, which return an uint64_t value\u000A*\t\t\t\tas representation of overhanded mask.\u000A*\t\t\t\tThis function can handle masks up to 64 elements!\u000A*\u000A* @return uint64_t value as representation of overhanded mask\u000A* @return 0 if no bit of mask is set\u000A*/\u000Atemplate<typename T, int B>\u000Auint64_t mask2int_uint64_t(fpvec<T,B>& mask) {\u000A\tuint64_t res = 0;\u000A\t#pragma unroll\t\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\tif (mask.elements[i] == 1) {\u000A\t\t\tif (i == 0) {\u000A\t\t\t\tres += 1;\u000A\t\t\t} else {\u000A\t\t\t\tuint64_t tmp = 1;\u000A\t\t\t\t#pragma unroll\u000A\t\t\t\tfor (int j=1; j<=i; j++) {\u000A\t\t\t\t\ttmp = tmp * 2;\u000A\t\t\t\t}\u000A\t\t\t\tres += tmp;\u000A\t\t\t}\u000A\t\t}\u000A\t}\u000A\treturn res;\u000A}\u000A\u000A/**\t#10\u000A* serial primitive for Intel Intrinsic:\u000A* __mmask16 _mm512_knot (__mmask16 a)\u000A* original description: \"Compute the bitwise NOT of 16-bit mask a, and store the result in k.\"\u000A*/\u000Atemplate<typename T, int B>\u000Afpvec<T,B> knot(fpvec<T,B>& src) {\u000A\tauto reg = fpvec<T,B>{};\u000A\t#pragma unroll\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\tif (src.elements[i] == 0) {\u000A\t\t\treg.elements[i] = 1;\u000A\t\t}\u000A\t\telse {\u000A\t\t\treg.elements[i] = 0;\u000A\t\t}\u000A\t}\u000A\treturn reg;\u000A}\u000A\u000A/**\t#11\u000A* serial primitive for Built-in Function Provided by GCC:\u000A* int __builtin_clz (unsigned int x)\u000A* original description: \"Built-in Function: int __builtin_clz (unsigned int x)\u000A* Returns the number of leading 0-bits in x, starting at the most significant bit position. \u000A* If x is 0, the result is undefined.\"\u000A*/\u000Atemplate<typename T, int B>\u000AType clz_onceBultin(fpvec<T,B>& src) {\u000A\tType res = 0;\u000A\t#pragma unroll\u000A\tfor (int i=((B/sizeof(T))-1); i>=0; i--) {\u000A\t\tif (src.elements[i]==0) {\u000A\t\t\tres = res+1;\u000A\t\t} else {\u000A\t\t\tbreak;\u000A\t\t}\u000A\t}\u000A\treturn res;\u000A}\u000A\u000A/**\t#12\u000A* serial primitive for Intel Intrinsic:\u000A* __m512i _mm512_load_epi32 (void const* mem_addr)\u000A* original description: \"Load 512-bits (composed of 16 packed 32-bit integers) from memory into dst. \u000A* mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.\"\u000A*\u000A* customized load-function:\u000A* @param data : array which contains the data that should be loaded\u000A* @param startIndex : first index-position of data from where the data should be loaded\u000A*/\u000Atemplate<typename T, int B>\u000Afpvec<T,B> load_epi32(std::array<Type, HSIZE>& data, uint32_t startIndex) {\u000A\tauto reg = fpvec<T,B>{};\u000A\t#pragma unroll\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\treg.elements[i] = data[startIndex+i];\u000A\t}\u000A\treturn reg;\u000A}\u000A\u000A/**\t#13\u000A* serial primitive for Intel Intrinsic:\u000A* __mmask16 _mm512_cmpeq_epi32_mask (__m512i a, __m512i b)\u000A* original description: \"Compare packed 32-bit integers in a and b for equality, and store the results in mask vector k.\"\u000A*/\u000Atemplate<typename T, int B>\u000Afpvec<T,B> cmpeq_epi32_mask(fpvec<T,B>& a, fpvec<T,B>& b) {\u000A\tauto reg = fpvec<T,B>{};\u000A\t#pragma unroll\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\tif (a.elements[i] == b.elements[i]) {\u000A\t\t\treg.elements[i] = 1;\u000A\t\t}\u000A\t\telse {\u000A\t\t\treg.elements[i] = 0;\u000A\t\t}\u000A\t}\u000A\treturn reg;\u000A}\u000A\u000A/**\t#14\u000A* serial primitive for Intel Intrinsic:\u000A* __m512i _mm512_permutexvar_epi32 (__m512i idx, __m512i a)\u000A* original description: \"Shuffle 32-bit integers in a across lanes using the corresponding index in idx, and store the results in dst.\"\u000A*/\u000Atemplate<typename T, int B>\u000Afpvec<T,B> permutexvar_epi32(fpvec<T,B>& idx, fpvec<T,B>& a) {\u000A\tauto reg = fpvec<T,B>{};\u000A\t#pragma unroll\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\tT id = idx.elements[i];\u000A\t\tT value = a.elements[id];\u000A\t\treg.elements[i] = value;\u000A\t}\u000A\treturn reg;\u000A}\u000A\u000A/**\t#15\u000A* serial primitive for Built-in Function Provided by GCC:\u000A* int __builtin_ctz (unsigned int x)\u000A* original description: \"Built-in Function: int __builtin_ctz (unsigned int x)\u000A* Returns the number of trailing 0-bits in x, starting at the least significant bit position. \u000A* If x is 0, the result is undefined.\"\u000A*/\u000Atemplate<typename T, int B>\u000AType ctz_onceBultin(fpvec<T,B>& src) {\u000A\tType res = 0;\u000A\t#pragma unroll\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\tif (src.elements[i]==0) {\u000A\t\t\tres = res+1;\u000A\t\t} else {\u000A\t\t\tbreak;\u000A\t\t}\u000A\t}\u000A\treturn res;\u000A}\u000A\u000A////////////////////////////////////////////////////////////////////////////\u000A////////////////////////////////////////////////////////////////////////////\u000A//// New functions for SoAoV approach only - not in SoA-implementations ////\u000A////////////////////////////////////////////////////////////////////////////\u000A////////////////////////////////////////////////////////////////////////////\u000A\u000A/**\t#16 \u000A* serial primitive for Intel Intrinsic:\u000A* __m512i _mm512_mask_set1_epi32 (__m512i src, __mmask16 k, int a)\u000A* original description: \"Broadcast 32-bit integer a to all elements of dst using \u000A* writemask k (elements are copied from src when the corresponding mask bit is not set).\"\u000A*/\u000Atemplate<typename T, int B>\u000Afpvec<T,B> mask_set1(fpvec<T,B>& src, fpvec<T,B>& writeMask, Type value) {\u000A\tauto reg = fpvec<T,B>{};\u000A\t#pragma unroll\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\tif(writeMask.elements[i] == 1) {\u000A\t\t\treg.elements[i] = value;\u000A\t\t} else {\u000A\t\t\treg.elements[i] = src.elements[i];\u000A\t\t}\t\t\u000A\t}\u000A\treturn reg;\u000A}\u000A\u000A/**\t#17\u000A* serial primitive for Intel Intrinsic:\u000A* void _mm512_store_epi32 (void* mem_addr, __m512i a)\u000A* original description: \"Store 512-bits (composed of 16 packed 32-bit integers) from a into memory. \u000A* mem_addr must be aligned on a 64-byte boundary or a general-protection exception may be generated.\"\u000A*\u000A* customized store  - function:\u000A* @param result : array, in which the data is stored; function store 512, 1024, 1536 or 2048 bits\u000A* @param startIndex : first index - position of data from where the data should be stored\u000A* @param data : register-array which contains the data that should be stored\u000A*/\u000Atemplate<typename T, int B>\u000Avoid store_epi32(Type* result, uint32_t startIndex, fpvec<T,B>& data) {\t\t\t\t// We use THIS function only for the SoAoV approach, to store back the vectors to the global memory\u000A\t#pragma unroll\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\tresult[(startIndex+i)] = data.elements[i];\u000A\t}\u000A}\u000A\u000A\u000A///////////////////////////////////////////////////////////////////////////////////////////\u000A///////////////////////////////////////////////////////////////////////////////////////////\u000A////////// Functions to load 512bit or 2048 bit onto FPGA within one clock cycle //////////\u000A///////////////////////////////////////////////////////////////////////////////////////////\u000A///////////////////////////////////////////////////////////////////////////////////////////\u000A\u000A/**\t#18\u000A* Own function to load 1*512bit with one DMA within one clock cycle from global memory onto FPGA\u000A*/\u000Atemplate<typename T, int B>\u000Afpvec<T,B> load(T* p, int i_cnt) {\u000A\tconst int i_localConst = i_cnt;\u000A    auto reg = fpvec<T,B>{};\u000A    #pragma unroll\u000A    for (uint idx = 0; idx < (B/sizeof(T)); idx++) {\u000A          reg.elements[idx] = p[idx + i_localConst * (B/sizeof(T))];\u000A    }\u000A    return reg;\u000A}\u000A\u000A\u000A/**\t#19\u000A* Own function to load 4*512bit (2048bit, 256 byte) (= complete CL (register)) in one clock cycle from input array\u000A* Load complete CL (register) in one clock cycle (same for PCIe and DDR4) \u000A* Function is based on the approach of parallel load with all 4 memory controller \u000A*/\u000Atemplate<typename T, int B>\u000Afpvec<T,B> maxLoad_per_clock_cycle(T* input, size_t kNumLSUs, size_t kValuesPerLSU, const int chunk_idx, const size_t kValuesPerInterleavedChunk, const int chunk_offset) {\u000A\tauto reg = fpvec<T,B>{};\u000A\t// Load complete CL in one clock cycle, (same for PCIe and DDR4)\u000A\t#pragma unroll\u000A\tfor (size_t l = 0; l < kNumLSUs; l++) {\u000A\t\t#pragma unroll\u000A\t\tfor (size_t k = 0; k < kValuesPerLSU; k++) {\u000A\t\t\t\t\t\t\t\u000A\t\t\tconst int idx = (chunk_idx*kValuesPerInterleavedChunk*kNumLSUs)\u000A\t\t\t\t\t\t\t+ (chunk_offset*kValuesPerLSU)\u000A\t\t\t\t\t\t\t+ (l*kValuesPerInterleavedChunk)\u000A\t\t\t\t\t\t\t+ k;\u000A\u000A\t\t\treg.elements[l*kValuesPerLSU+k] = input[idx];\u000A\t\t}\u000A\t}\t\u000A    return reg;\u000A}\u000A\u000A////////////////////////////////////////////////////////////////////////////////////////\u000A////////////////////////////////////////////////////////////////////////////////////////\u000A////////// New functions to calculate overflow -  independant of elementCount //////////\u000A////////////////////////////////////////////////////////////////////////////////////////\u000A////////////////////////////////////////////////////////////////////////////////////////\u000A\u000A/**\t#20\u000A* Own function to create the overflow_correction_mask\u000A*/\u000Atemplate<typename T, int B>\u000Afpvec<T,B> createOverflowCorrectionMask(T oferflowUnsigned) {\u000A\tauto reg = fpvec<T,B>{};\u000A\tconst int overflow = (B/sizeof(T)) - oferflowUnsigned;\u000A\tType one = 1;\u000A\tType zero = 0;\u000A\t#pragma unroll\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\tif (i<overflow) {\u000A\t\t\treg.elements[i] = one;\u000A\t\t}\u000A\t\telse {\u000A\t\t\treg.elements[i] = zero;\u000A\t\t}\t\t\u000A\t}\u000A\treturn reg;\u000A} \u000A\u000A/**\t#21\u000A* Own function to create the cutlow_mask\u000A*/\u000Atemplate<typename T, int B>\u000Afpvec<T,B> createCutlowMask(T cutlowUnsigned) {\u000A\tauto reg = fpvec<T,B>{};\u000A\tconst int cutlow_const = (B/sizeof(T)) - cutlowUnsigned;\u000A\tType one = 1;\u000A\tType zero = 0;\u000A\t#pragma unroll\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\tif (i<cutlow_const) {\u000A\t\t\treg.elements[i] = zero;\u000A\t\t}\u000A\t\telse {\u000A\t\t\treg.elements[i] = one;\u000A\t\t}\t\t\u000A\t}\u000A\treturn reg;\u000A} \u000A\u000A////////////////////////////////////////////////////////////////////////////////////////\u000A////////////////////////////////////////////////////////////////////////////////////////\u000A////////////  New functions for LinearProbing_v5 == soa_conflict_v1  ///////////////////\u000A////////////////////////////////////////////////////////////////////////////////////////\u000A////////////////////////////////////////////////////////////////////////////////////////\u000A\u000A/**\t#22\u000A* serial primitive for Intel Intrinsic:\u000A* __m512i _mm512_conflict_epi32 (__m512i a)\u000A* original description: \"Test each 32-bit element of a for equality with all other elements in a closer to the least significant bit. Each element's comparison forms a zero extended bit vector in dst.\"\u000A* \u000A* customized conflict_epi32 - function:\u000A* This function check whether an element is already in the vector. \u000A* Only elements with a lower index are checked. \u000A* As a result, element 0 in the vector never has a conflict. The bits for each element are then set accordingly. \u000A* IMPORTANT: At the point where a conflict is found, the position of the first occurrence is written! \u000A* IMPORTANT: The position is specified from 1 to #elementCount (NOT 0-n-1) !!\u000A*\u000A* adjustment against original Intel Intrinsic:\u000A* 104 71 106 116 82 128 75 109 42 78 59 44 115 124 100 71 --> 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 \u000A* 104 71  71 116 82  71 75 109 42 78 59 44 115 124 100 71 --> 0 0 2 0 0 2 0 0 0 0 0 0 0 0 0 2 \u000A*/\u000Atemplate<typename T, int B>\u000Afpvec<T,B> conflict_epi32(fpvec<T,B>& a) {\u000A\tauto reg = fpvec<T,B>{};\u000A\t#pragma unroll\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\tType currentElement = a.elements[i];\u000A\t\t#pragma unroll\u000A\t\tfor (int j=0; j<i; j++) {\u000A\t\t\tif(a.elements[j] == currentElement) {\u000A\t\t\t\treg.elements[i] = (Type)(j+1);\u000A\t\t\t\tj=i;\t\u000A\t\t\t\tbreak;\t\t\t\u000A\t\t\t}\u000A\t\t}\u000A\t}\t\u000A\treturn reg;\u000A}\u000A\u000A\u000A/**\t#23\u000A* serial primitive for Intel Intrinsic:\u000A* void _mm512_mask_compressstoreu_epi32 (void* base_addr, __mmask16 k, __m512i a)\u000A* original description: \"Contiguously store the active 32-bit integers in a (those with their respective bit set in writemask k) to unaligned memory at base_addr.\"\u000A*\u000A* @param buffer : \u000A* @param writeMask : \u000A* @param data : \u000A*/\u000Atemplate<typename T, int B>\u000Avoid mask_compressstoreu_epi32(std::array<Type, elements_per_inner_register>& buffer, fpvec<T,B>& writeMask, fpvec<T,B>& data) {\u000A\tint buffer_position = 0;\u000A\t#pragma unroll\t\t\t\t\t\t\t\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\tif (writeMask.elements[i] == 1) {\u000A\t\t\tbuffer[buffer_position] = (Type)data.elements[i];\u000A\t\t\tbuffer_position++;\u000A\t\t}\u000A\t}\u000A}\u000A\u000A/**\t#24\u000A* serial primitive for Built-in Function Provided by GCC:\u000A* int __builtin_popcount(int number)\u000A* original description: \"This function is used to count the number of set bits in an unsigned integer. \"\u000A* \u000A* Adjustment: We don't hand over an integer, we handle a register directly within the function and count the \"1\" within this register.\u000A* return: count of \"!=0\" within this register\u000A*/\u000Atemplate<typename T, int B>\u000AType popcount_builtin(fpvec<T,B>& mask) {\u000A\tType count = 0;\u000A\t#pragma unroll\t\t\t\t\t\t\t\t\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\tif (mask.elements[i] != 0) {\u000A\t\t\tcount++;\u000A\t\t}\u000A\t}\u000A\treturn count;\u000A}\u000A\u000A/**\t#25\u000A* adaption of:\u000A* __m512i _mm512_set1_epi32 (int a)\u000A*\u000A* function create a fpvec<T,B> with all values zero; except at position (value-1) => 1\u000A*/\u000Atemplate<typename T, int B>\u000Afpvec<T,B> setX_singleValue(T value) {\u000A\tauto reg = fpvec<T,B>{};\u000A\t#pragma unroll\t\t\t\t\t\t\t\t\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\treg.elements[i] = 0;\u000A\t}\u000A\treg.elements[value-1] = 1;\u000A\treturn reg;\u000A}\u000A\u000A/**\t#25.1\u000A* adaption of:\u000A* __m512i _mm512_set1_epi32 (int a)\u000A*\u000A* create an empty register reg\u000A* add \"1\" to this register at every position contained in buffer (value-1) !\u000A* size_t conflict_count = amount of conflicts contained in buffer\u000A* \u000A*/\u000Atemplate<typename T, int B>\u000Afpvec<T,B> setX_multipleValues(std::array<Type, elements_per_inner_register>& buffer, size_t conflict_count) {\u000A\tauto reg = fpvec<T,B>{};\u000A\tfor(int i=0; i<conflict_count; i++) {\u000A\t\treg.elements[(buffer[i] - 1)] += 1; \u000A\t}\u000A\treturn reg;\u000A}\u000A\u000A/**\t#26\u000A* serial primitive for Intel Intrinsic:\u000A* __m512i _mm512_mask_i32gather_epi32 (__m512i src, __mmask16 k, __m512i vindex, void const* base_addr, int scale)\u000A* original description: \"Gather 32-bit integers from memory using 32-bit indices. 32-bit elements are loaded from addresses starting \u000A* \tat base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). Gathered elements are merged \u000A*\tinto dst using writemask k (elements are copied from src when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.\"\u000A* \u000A* @param src : register of type fpvec<T,B>\u000A* @param mask_k : writemask k (= register of type fpvec<T,B>)\u000A* @param vindex : register of type fpvec<T,B> \u000A* @param data : void const* base_addr\u000A* @param scale : scale should be 1, 2, 4 or 8\u000A*\t\t-> we don't need an additional scale factor in our implementation, since we always count in whole elements of the registers/arrays\t\u000A*/\u000Atemplate<typename T, int B>\u000Afpvec<T,B> mask_i32gather_epi32(fpvec<T,B>& src, fpvec<T,B>& mask_k, fpvec<T,B>& vindex, std::array<Type, HSIZE>& data) {\u000A\tauto reg = fpvec<T,B>{};\u000A\t#pragma unroll\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\tif(mask_k.elements[i] == (Type)1) {\u000A\t\t\tsize_t addr = 0 + vindex.elements[i];\t// * scale * 8;\t\u000A\t\t\t\t\t\t// 0, because hashVec and countVec starting both at index 0\u000A\t\t\t\t\t\t// omit *8 (because we don't need bit conversion)\u000A\t\t\t\t\t\t// omit *scale, because we currently work with Type=uint32_t in all stages\u000A\t\t\t\t\t\t// if we want to use another datatype, we may adjust the scale paramter within\u000A\t\t\t\t\t\t// this function; now scale doesn't have an usage\u000A\t\t\treg.elements[i] = data[addr];\t\t\t\t\t\t\t\t\t\t\t\t\t\u000A\t\t} else {\u000A\t\t\treg.elements[i] = src.elements[i];\u000A\t\t}\u000A\t}\u000A\treturn reg;\u000A}\u000A\u000A/**\t#27\u000A* serial primitive for Intel Intrinsic:\u000A* __m512i _mm512_maskz_add_epi32 (__mmask16 k, __m512i a, __m512i b)\u000A* original description: \"Add packed 32-bit integers in a and b, and store the results in dst using zeromask k \u000A* (elements are zeroed out when the corresponding mask bit is not set).\"\u000A*/\u000Atemplate<typename T, int B>\u000Afpvec<T,B> maskz_add_epi32(fpvec<T,B>& writeMask, fpvec<T,B>& a, fpvec<T,B>& b) {\u000A\tauto reg = fpvec<T,B>{};\u000A\t#pragma unroll\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\tif (writeMask.elements[i] == 1) {\u000A\t\t\treg.elements[i] = a.elements[i] + b.elements[i];\u000A\t\t}\u000A\t}\u000A\treturn reg;\u000A}\u000A\u000A/**\t#28\u000A* serial primitive for Intel Intrinsic:\u000A* void _mm512_mask_i32scatter_epi32 (void* base_addr, __mmask16 k, __m512i vindex, __m512i a, int scale)\u000A* original description: \"Scatter 32-bit integers from a into memory using 32-bit indices. 32-bit elements are stored at \u000A*\t\taddresses starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale) \u000A*\t\tsubject to mask k (elements are not stored when the corresponding mask bit is not set). scale should be 1, 2, 4 or 8.\"\u000A* \u000A* @param datbaseStoragea : void const* base_addr for storage/scatter\u000A* @param mask_k : writemask k (= register of type fpvec<T,B>)\u000A* @param vindex : register of type fpvec<T,B> \u000A* @param data_to_scatter : register of type fpvec<T,B>\u000A* @param scale : scale should be 1, 2, 4 or 8\t\t\u000A*\t\t-> we don't need an additional scale factor in our implementation, since we always count in whole elements of the registers/arrays\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\u000A* @param tmp_HSIZE : global HashSize (=size of hashVec and countVec) to avoid scatter over the vector borders through false offsets\t\t\u000A*\t\t-> we don't need an additional scale factor in our implementation, since we always count in whole elements of the registers/arrays\t\u000A*/\u000Atemplate<typename T, int B>\u000Avoid mask_i32scatter_epi32(std::array<Type, HSIZE>& baseStorage, fpvec<T,B>& mask_k, fpvec<T,B>& vindex, fpvec<T,B>& data_to_scatter) {\u000A\t#pragma unroll\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\tif(mask_k.elements[i] == (Type)1) {\u000A\t\t\tType addr = 0 + vindex.elements[i];\t\u000A\t\t\t\t\t\t// 0, because hashVec and countVec starting both at index 0\u000A\t\t\t\t\t\t// omit *8 (because we don't need bit conversion)\u000A\t\t\t\t\t\t// omit *scale, because we currently work with Type=uint32_t in all stages\u000A\t\t\t\t\t\t// if we want to use another datatype, we may adjust the scale paramter within\u000A\t\t\t\t\t\t// this function; now scale doesn't have an usage\u000A\t\t\t// if (addr >= HSIZE) { addr = HSIZE-addr; }\t\t\t\t\t\t\u000A\t\t\tbaseStorage[addr] = (Type)data_to_scatter.elements[i];\t\t\t\t\t\t\t\t\t\t\t\t\t\u000A\t\t} \u000A\t}\u000A}\u000A\u000A/**\t#29\u000A* serial primitive for Intel Intrinsic:\u000A* __mmask16 _mm512_kandn (__mmask16 a, __mmask16 b)\u000A* original description: \"Compute the bitwise NOT of (16/...)-bit masks a and then AND with b, and store the result in k.\"\u000A*\u000A* Note: registers a and b may only contain elements of the datatype Type (currently uint32_t) with values ONLY 1 or 0 !!\u000A*/\u000Atemplate<typename T, int B>\u000Afpvec<T,B> kAndn(fpvec<T,B>& a, fpvec<T,B>& b) {\u000A\tauto reg = fpvec<T,B>{};\u000A\t#pragma unroll\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\t\treg.elements[i] = ((~(a.elements[i]))&(b.elements[i]));\u000A\t}\u000A\treturn reg;\u000A}\u000A\u000A/**\t#30\u000A* serial primitive for Intel Intrinsic:\u000A* __mmask16 _mm512_kand (__mmask16 a, __mmask16 b)\u000A* original description: \"Compute the bitwise AND of 16-bit masks a and b, and store the result in k.\"\u000A*\u000A* Note: registers a and b may only contain elements of the datatype Type (currently uint32_t) with values ONLY 1 or 0 !!\u000A*/\u000Atemplate<typename T, int B>\u000Afpvec<T,B> kAnd(fpvec<T,B>& a, fpvec<T,B>& b) {\u000A\tauto reg = fpvec<T,B>{};\u000A\t#pragma unroll\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\treg.elements[i] = ((a.elements[i])&(b.elements[i]));\u000A\t}\u000A\treturn reg;\u000A}\u000A\u000A/**\t#31\u000A* serial primitive for Intel Intrinsic:\u000A* __m512i _mm512_maskz_conflict_epi32 (__mmask16 k, __m512i a)\u000A* original description: \"Test each 32-bit element of a for equality with all other elements in a closer to the least significant bit using zeromask k \u000A* \t\t\t(elements are zeroed out when the corresponding mask bit is not set). Each element's comparison forms a zero extended bit vector in dst.\"\u000A* \u000A* customized maskz_conflict_epi32 - function:\u000A* This function check whether an element is already in the vector a. \u000A* Only elements with a lower index are checked. \u000A* As a result, element 0 in the vector never has a conflict. The bits for each element are then set accordingly. \u000A*\u000A* example:\u000A* index :\t\t\t\t\t\t\t  0  1   2  3  4   5  6   7  8  9 10 11  12  13  14 15\u000A* input array (e.g. loaded values):\t104 71 106 82 82 128 75 109 82 94 59 44 115 124 100 94 \u000A* result of conflict_epi32:\t\t\t  0  0   0  0  8   0  0   0 24  0  0  0   0   0   0 512 \u000A* example input[0..15]\u000A* 1st conflict @ input[4] : 0 0 0 1 ..0 == 0 + 0 + 0 + 2^3 = 8\u000A* 2st conflict @ input[8] : 0 0 0 1 1 ..0 = 0 + 0 + 0 + 2^3 + 2^4 = 24\u000A* 3st conflict @ input[15]: 0 0 0 0 0 0 0 0 1 ..0 = 0 + .. + 0 + 2^9 = 512\u000A*\u000A* Difference against conflict_epi32:\tadditional fpvec<T,B>& mask_k : if mask_k[i]==0 --> result[0]=0 ; else do conflict_epi32 algorithm\u000A* \u000A* @param mask_k\t- writing mask mask_k : if mask_k[i]==0 --> result[0]=0 ; else do conflict_epi32 algorithm\u000A* @param a\t\t- register a : the register in which the algorithm search for conflicts\u000A* @param match_32bit\t-\tan array which contain the exponentation results for 2^m at position m of match_32bit\u000A*/\u000Atemplate<typename T, int B>\u000Afpvec<T,B> maskz_conflict_epi32(fpvec<T,B>& mask_k, fpvec<T,B>& a) {\u000A\tauto reg = fpvec<T,B>{};\u000A\tType match_32bit[32] = {\u000A\t\t0x00000001, 0x00000002, 0x00000004, 0x00000008,\t\u000A\t\t0x00000010, 0x00000020, 0x00000040, 0x00000080,\t\t\t\u000A\t\t0x00000100, 0x00000200, 0x00000400, 0x00000800,\t\t\u000A\t \t0x00001000, 0x00002000, 0x00004000, 0x00008000,\t\t\u000A\t \t0x00010000,\t0x00020000, 0x00040000, 0x00080000,\t\t\u000A\t \t0x00100000,\t0x00200000, 0x00400000, 0x00800000,\t\t\u000A\t \t0x01000000,\t0x02000000, 0x04000000, 0x08000000,\t\t\u000A\t \t0x10000000, 0x20000000, 0x40000000, 0x80000000\t\u000A\t};\u000A\t#pragma unroll\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\tType currentElement = a.elements[i];\u000A\t\tType conflict_calculation = 0x00000000;\u000A\t\tconst int upper_limit = i;\u000A\t\t#pragma unroll\u000A\t\tfor (int j=0; j<upper_limit; j++) {\u000A\t\t\tif((mask_k.elements[upper_limit] == 1) && (a.elements[j] == currentElement)) {\u000A\t\t\t\t// calculate exponentiation\u000A\t\t\t\t/*if (j == 0) {\u000A\t\t\t\t\tconflict_calculation += 1;\u000A\t\t\t\t} else {\u000A\t\t\t\t\tuint64_t tmp = 1;\u000A\t\t\t\t\tfor (int k=1; k<=j; k++) {\u000A\t\t\t\t\t\ttmp = tmp * 2;\u000A\t\t\t\t\t}\u000A\t\t\t\t\tconflict_calculation += tmp;\u000A\t\t\t\t}*/\u000A\t\t\t\tconflict_calculation += match_32bit[j]; \u000A\t\t\t}\u000A\t\t}\t\u000A\t\treg.elements[i] = conflict_calculation;\u000A\t}\t\u000A\treturn reg;\u000A}\u000A\u000A/**\t#32\u000A* serial primitive for Intel Intrinsic:\u000A* __m512i _mm512_and_epi32 (__m512i a, __m512i b)\u000A* original description: \"Compute the bitwise AND of packed 32-bit integers in a and b, and store the results in dst.\"\u000A*/\u000Atemplate<typename T, int B>\u000Afpvec<T,B> register_and(fpvec<T,B>& a, fpvec<T,B>& b) {\u000A\tauto reg = fpvec<T,B>{};\u000A\t#pragma unroll\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\treg.elements[i] = (a.elements[i] & b.elements[i]);\u000A\t}\u000A\treturn reg;\u000A}\u000A\u000A/**\t#33\u000A* serial primitive for Intel Intrinsic:\u000A* __mmask16 _mm512_mask_cmp_epi32_mask (__mmask16 k1, __m512i a, __m512i b, _MM_CMPINT_ENUM imm8)\u000A* original description: \"Compare packed signed 32-bit integers in a and b based on the comparison operand specified by imm8,\u000A* \tand store the results in mask vector k using zeromask k1 (elements are zeroed out when the corresponding mask bit is not set).\"\u000A*\u000A* NOTE: adjust function to handle ONLY the _MM_CMPINT_NLT (Not less than) comparison, due to the fact that this is the only scenario,\u000A*\t\twhich is used in LinearProbing_v5 (SoA_conflict_v1); Thereby an additional parameter for the cmp type isn't necessary anymore.\u000A*/\u000Atemplate<typename T, int B>\u000Afpvec<T,B> mask_cmp_epi32_mask_NLT(fpvec<T,B>& zeroMask, fpvec<T,B>& a, fpvec<T,B>& b) {\u000A\tauto reg = fpvec<T,B>{};\u000A\t#pragma unroll\u000A\tfor (int i=0; i<(B/sizeof(T)); i++) {\u000A\t\tif ((zeroMask.elements[i] == 1) && (a.elements[i] < b.elements[i])) {\u000A\t\t\treg.elements[i] = 0;\u000A\t\t}\t\u000A\t\telse {\u000A\t\t\treg.elements[i] = 1;\u000A\t\t}\u000A\t}\t\u000A\treturn reg;\u000A}\u000A////////////////////////////////////////////////////////////////////////////////////////\u000A////////////////////////////////////////////////////////////////////////////////////////\u000A#endif // PRIMITIVES_HPP"}, {"path":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/tbb/2021.8.0/include/tbb/tbb.h", "name":"tbb.h", "has_active_debug_locs":false, "absName":"/glob/development-tools/versions/oneapi/2023.0.1/oneapi/tbb/2021.8.0/include/tbb/tbb.h", "content":"/*\u000A    Copyright (c) 2005-2021 Intel Corporation\u000A\u000A    Licensed under the Apache License, Version 2.0 (the \"License\");\u000A    you may not use this file except in compliance with the License.\u000A    You may obtain a copy of the License at\u000A\u000A        http://www.apache.org/licenses/LICENSE-2.0\u000A\u000A    Unless required by applicable law or agreed to in writing, software\u000A    distributed under the License is distributed on an \"AS IS\" BASIS,\u000A    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\u000A    See the License for the specific language governing permissions and\u000A    limitations under the License.\u000A*/\u000A\u000A#include \"../oneapi/tbb.h\"\u000A"}];
var alpha_viewer=false;